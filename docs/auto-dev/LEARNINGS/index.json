{
  "items": [
    {
      "id": "LRN-001",
      "title": "PyO3 Method Chaining with PyRefMut",
      "tags": [
        "rust",
        "pyo3",
        "patterns",
        "builder"
      ],
      "created": "2026-01-26T17:17:25.712714Z",
      "source": "v001 retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "PyO3 Method Chaining with PyRefMut",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-001-pyo3-method-chaining-with-pyrefmut.md",
      "status": "active"
    },
    {
      "id": "LRN-002",
      "title": "Frame-Accurate Timeline Math",
      "tags": [
        "rust",
        "video",
        "precision",
        "math"
      ],
      "created": "2026-01-26T17:17:36.777238Z",
      "source": "v001 retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Frame-Accurate Timeline Math",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-002-frame-accurate-timeline-math.md",
      "status": "active"
    },
    {
      "id": "LRN-003",
      "title": "Security Validation Whitelist Pattern",
      "tags": [
        "security",
        "validation",
        "patterns"
      ],
      "created": "2026-01-26T17:17:48.490846Z",
      "source": "v001 retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Security Validation Whitelist Pattern",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-003-security-validation-whitelist-pattern.md",
      "status": "active"
    },
    {
      "id": "LRN-004",
      "title": "Deepcopy Isolation for InMemory Test Doubles",
      "tags": [
        "testing",
        "patterns",
        "isolation",
        "test-doubles"
      ],
      "created": "2026-02-09T06:32:54.305332Z",
      "source": "v004/01-test-foundation/001-inmemory-test-doubles",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "InMemory test doubles must deepcopy on both read and write operations to prevent mutation leakage between tests.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-004-deepcopy-isolation-for-inmemory-test-doubles.md",
      "status": "active"
    },
    {
      "id": "LRN-005",
      "title": "Constructor DI over dependency_overrides for FastAPI Testing",
      "tags": [
        "testing",
        "fastapi",
        "dependency-injection",
        "patterns"
      ],
      "created": "2026-02-09T06:33:03.120095Z",
      "source": "v004/01-test-foundation/002-dependency-injection",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Use create_app() constructor parameters instead of FastAPI dependency_overrides for cleaner, explicit test wiring without global mutable state.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-005-constructor-di-over-dependency-overrides-for-fasta.md",
      "status": "active"
    },
    {
      "id": "LRN-006",
      "title": "Builder Pattern with Dual Output Modes for Test Fixtures",
      "tags": [
        "testing",
        "patterns",
        "builder",
        "fixtures"
      ],
      "created": "2026-02-09T06:33:11.428278Z",
      "source": "v004/01-test-foundation/003-fixture-factory",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Test fixture factories with dual output modes (build for unit tests, create_via_api for integration tests) provide flexibility without forcing a single testing style.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-006-builder-pattern-with-dual-output-modes-for-test-fi.md",
      "status": "active"
    },
    {
      "id": "LRN-007",
      "title": "Parity Tests Prevent Test Double Drift",
      "tags": [
        "testing",
        "patterns",
        "parity",
        "test-doubles",
        "contracts"
      ],
      "created": "2026-02-09T06:33:20.272780Z",
      "source": "v004/01-test-foundation, 02-blackbox-contract/003-search-unification",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Parity tests running identical operations against InMemory fakes and real implementations catch behavioral drift automatically.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-007-parity-tests-prevent-test-double-drift.md",
      "status": "active"
    },
    {
      "id": "LRN-008",
      "title": "Record-Replay with Strict Mode for External Dependency Testing",
      "tags": [
        "testing",
        "patterns",
        "record-replay",
        "external-dependencies",
        "contracts"
      ],
      "created": "2026-02-09T06:33:29.168741Z",
      "source": "v004/02-blackbox-contract/002-ffmpeg-contract-tests",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Three-tier executor pattern (Real/Recording/Fake) with strict argument verification enables reliable testing of external dependencies.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-008-record-replay-with-strict-mode-for-external-depend.md",
      "status": "active"
    },
    {
      "id": "LRN-009",
      "title": "Handler Registration Pattern for Generic Job Queues",
      "tags": [
        "architecture",
        "patterns",
        "job-queue",
        "dependency-injection"
      ],
      "created": "2026-02-09T06:33:43.143756Z",
      "source": "v004/03-async-scan/001-job-queue-infrastructure",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Explicit handler registration with factory-based dependency injection provides clean, testable job routing without global state.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-009-handler-registration-pattern-for-generic-job-queue.md",
      "status": "active"
    },
    {
      "id": "LRN-010",
      "title": "Prefer stdlib asyncio.Queue over External Queue Dependencies",
      "tags": [
        "architecture",
        "asyncio",
        "dependencies",
        "simplicity"
      ],
      "created": "2026-02-09T06:33:52.433360Z",
      "source": "v004/03-async-scan (cross-theme learning)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "stdlib asyncio.Queue with producer-consumer pattern eliminates external queue dependencies while meeting single-worker requirements.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-010-prefer-stdlib-asyncio-queue-over-external-queue-de.md",
      "status": "active"
    },
    {
      "id": "LRN-011",
      "title": "Python Business Logic, Rust Input Safety in Hybrid Architectures",
      "tags": [
        "architecture",
        "rust",
        "python",
        "hybrid",
        "security",
        "boundaries"
      ],
      "created": "2026-02-09T06:34:03.991539Z",
      "source": "v004/04-security-performance (cross-theme learning)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "In hybrid Python/Rust architectures, Rust handles input sanitization and type safety while Python handles business policy and domain rules.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-011-python-business-logic-rust-input-safety-in-hybrid-.md",
      "status": "active"
    },
    {
      "id": "LRN-012",
      "title": "PyO3 FFI Overhead Makes Rust Slower for Simple Operations",
      "tags": [
        "performance",
        "rust",
        "pyo3",
        "ffi",
        "benchmarking"
      ],
      "created": "2026-02-09T06:34:13.655405Z",
      "source": "v004/04-security-performance/002-performance-benchmark",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "PyO3 FFI overhead makes Rust 7-10x slower than Python for simple operations; Rust wins only for string-heavy processing (1.9x faster).",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-012-pyo3-ffi-overhead-makes-rust-slower-for-simple-ope.md",
      "status": "active"
    },
    {
      "id": "LRN-013",
      "title": "Progressive Coverage Thresholds for Bootstrapping Enforcement",
      "tags": [
        "ci",
        "coverage",
        "process",
        "thresholds"
      ],
      "created": "2026-02-09T06:34:22.507319Z",
      "source": "v004/05-devex-coverage/002-rust-coverage",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Start with conservative coverage thresholds and ratchet up after confirming baseline, avoiding false CI failures during initial enforcement.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-013-progressive-coverage-thresholds-for-bootstrapping-.md",
      "status": "active"
    },
    {
      "id": "LRN-014",
      "title": "Template-Driven Process Improvements Over Standalone Documentation",
      "tags": [
        "process",
        "templates",
        "documentation",
        "adoption"
      ],
      "created": "2026-02-09T06:34:37.018232Z",
      "source": "v004/05-devex-coverage/001-property-test-guidance",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Embed process improvements directly into existing templates rather than standalone docs to ensure adoption in standard workflows.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-014-template-driven-process-improvements-over-standalo.md",
      "status": "active"
    },
    {
      "id": "LRN-015",
      "title": "Single-Matrix CI Jobs for Expensive Operations",
      "tags": [
        "ci",
        "performance",
        "process",
        "github-actions"
      ],
      "created": "2026-02-09T06:34:47.073555Z",
      "source": "v004/05-devex-coverage/002-rust-coverage",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Run expensive CI operations on a single platform in separate jobs rather than across the full test matrix to keep CI fast.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-015-single-matrix-ci-jobs-for-expensive-operations.md",
      "status": "active"
    },
    {
      "id": "LRN-016",
      "title": "Validate Acceptance Criteria Against Codebase During Design",
      "tags": [
        "process",
        "design",
        "requirements",
        "validation"
      ],
      "created": "2026-02-09T06:34:56.481858Z",
      "source": "v004/01-test-foundation/003-fixture-factory, version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Validate that acceptance criteria reference existing domain models and APIs during design phase to prevent unachievable requirements during execution.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-016-validate-acceptance-criteria-against-codebase-duri.md",
      "status": "active"
    },
    {
      "id": "LRN-017",
      "title": "Empty Allowlist Means Unrestricted as Backwards-Compatible Default",
      "tags": [
        "security",
        "configuration",
        "backwards-compatibility",
        "patterns"
      ],
      "created": "2026-02-09T06:35:04.869022Z",
      "source": "v004/04-security-performance/001-security-audit",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Empty allowlist defaulting to unrestricted preserves backwards compatibility while letting production environments lock down access explicitly.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-017-empty-allowlist-means-unrestricted-as-backwards-co.md",
      "status": "active"
    },
    {
      "id": "LRN-018",
      "title": "Audit-Then-Fix Is More Efficient Than Blanket Changes",
      "tags": [
        "process",
        "code-quality",
        "auditing",
        "pragmatism"
      ],
      "created": "2026-02-09T06:35:14.543926Z",
      "source": "v004/05-devex-coverage/003-coverage-gap-fixes",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Catalogue all suppressions first, evaluate justification, then fix only unjustified ones â€” prevents unnecessary churn from blanket changes.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-018-audit-then-fix-is-more-efficient-than-blanket-chan.md",
      "status": "active"
    },
    {
      "id": "LRN-019",
      "title": "Build Infrastructure First in Sequential Version Planning",
      "tags": [
        "process",
        "planning",
        "architecture",
        "sequencing"
      ],
      "created": "2026-02-09T06:35:28.304735Z",
      "source": "v004 version retrospective (cross-theme learning)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Sequence infrastructure themes before consumer themes in version planning; the upfront investment pays off when subsequent themes consume the infrastructure.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-019-build-infrastructure-first-in-sequential-version-p.md",
      "status": "active"
    },
    {
      "id": "LRN-020",
      "title": "Conditional Static Mount Pattern for Optional Frontend Serving",
      "tags": [
        "fastapi",
        "patterns",
        "testing",
        "frontend",
        "static-files"
      ],
      "created": "2026-02-09T18:54:06.211262Z",
      "source": "v005/01-frontend-foundation, v005/04-e2e-testing",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Only mount StaticFiles when the directory exists to decouple backend testing from frontend build state; auto-load from settings for seamless production serving.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-020-conditional-static-mount-pattern-for-optional-fron.md",
      "status": "active"
    },
    {
      "id": "LRN-021",
      "title": "Separate Vitest Config for Vite 7+ Projects",
      "tags": [
        "frontend",
        "vite",
        "vitest",
        "typescript",
        "configuration"
      ],
      "created": "2026-02-09T18:54:14.315152Z",
      "source": "v005/01-frontend-foundation/001-frontend-scaffolding",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Vite 7 + Vitest 4 require separate vitest.config.ts; inline test config in vite.config.ts causes TypeScript errors.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-021-separate-vitest-config-for-vite-7-projects.md",
      "status": "active"
    },
    {
      "id": "LRN-022",
      "title": "Automated Accessibility Testing Catches Real Violations",
      "tags": [
        "accessibility",
        "testing",
        "e2e",
        "playwright",
        "wcag"
      ],
      "created": "2026-02-09T18:54:23.874701Z",
      "source": "v005/04-e2e-testing/002-e2e-test-suite",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Automated axe-core accessibility checks in E2E tests catch real WCAG violations cheaply; include them from the start rather than retrofitting.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-022-automated-accessibility-testing-catches-real-viola.md",
      "status": "active"
    },
    {
      "id": "LRN-023",
      "title": "Client-Side Navigation for SPA E2E Tests Without Server-Side Routing",
      "tags": [
        "e2e",
        "testing",
        "spa",
        "routing",
        "playwright"
      ],
      "created": "2026-02-09T18:54:34.266089Z",
      "source": "v005/04-e2e-testing/002-e2e-test-suite",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "SPA E2E tests must use client-side navigation (clicking UI elements) from root path when the server doesn't handle SPA fallback routing for sub-paths.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-023-client-side-navigation-for-spa-e2e-tests-without-s.md",
      "status": "active"
    },
    {
      "id": "LRN-024",
      "title": "Focused Zustand Stores Over Monolithic State Management",
      "tags": [
        "frontend",
        "react",
        "state-management",
        "zustand",
        "patterns"
      ],
      "created": "2026-02-09T18:54:45.662195Z",
      "source": "v005/03-gui-components (cross-theme pattern)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Use multiple focused Zustand stores scoped to feature domains with bounded eviction policies for lightweight, testable state management in React apps.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-024-focused-zustand-stores-over-monolithic-state-manag.md",
      "status": "active"
    },
    {
      "id": "LRN-025",
      "title": "Feature Handoff Documents Enable Zero-Rework Sequencing",
      "tags": [
        "process",
        "sequencing",
        "handoff",
        "documentation",
        "patterns"
      ],
      "created": "2026-02-09T18:54:55.806218Z",
      "source": "v005 version retrospective (cross-theme learning)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Feature handoff documents communicating integration points and patterns enable zero-rework feature chains when combined with correct sequencing.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-025-feature-handoff-documents-enable-zero-rework-seque.md",
      "status": "active"
    }
  ],
  "next_id": 26
}
{
  "items": [
    {
      "id": "LRN-001",
      "title": "PyO3 Method Chaining with PyRefMut",
      "tags": [
        "rust",
        "pyo3",
        "patterns",
        "builder"
      ],
      "created": "2026-01-26T17:17:25.712714Z",
      "source": "v001 retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "PyO3 Method Chaining with PyRefMut",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-001-pyo3-method-chaining-with-pyrefmut.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-002",
      "title": "Frame-Accurate Timeline Math",
      "tags": [
        "rust",
        "video",
        "precision",
        "math"
      ],
      "created": "2026-01-26T17:17:36.777238Z",
      "source": "v001 retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Frame-Accurate Timeline Math",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-002-frame-accurate-timeline-math.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-003",
      "title": "Security Validation Whitelist Pattern",
      "tags": [
        "security",
        "validation",
        "patterns"
      ],
      "created": "2026-01-26T17:17:48.490846Z",
      "source": "v001 retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Security Validation Whitelist Pattern",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-003-security-validation-whitelist-pattern.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-004",
      "title": "Deepcopy Isolation for InMemory Test Doubles",
      "tags": [
        "testing",
        "patterns",
        "isolation",
        "test-doubles"
      ],
      "created": "2026-02-09T06:32:54.305332Z",
      "source": "v004/01-test-foundation/001-inmemory-test-doubles",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "InMemory test doubles must deepcopy on both read and write operations to prevent mutation leakage between tests.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-004-deepcopy-isolation-for-inmemory-test-doubles.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-005",
      "title": "Constructor DI over dependency_overrides for FastAPI Testing",
      "tags": [
        "testing",
        "fastapi",
        "dependency-injection",
        "patterns"
      ],
      "created": "2026-02-09T06:33:03.120095Z",
      "source": "v004/01-test-foundation/002-dependency-injection",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Use create_app() constructor parameters instead of FastAPI dependency_overrides for cleaner, explicit test wiring without global mutable state.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-005-constructor-di-over-dependency-overrides-for-fasta.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-006",
      "title": "Builder Pattern with Dual Output Modes for Test Fixtures",
      "tags": [
        "testing",
        "patterns",
        "builder",
        "fixtures"
      ],
      "created": "2026-02-09T06:33:11.428278Z",
      "source": "v004/01-test-foundation/003-fixture-factory",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Test fixture factories with dual output modes (build for unit tests, create_via_api for integration tests) provide flexibility without forcing a single testing style.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-006-builder-pattern-with-dual-output-modes-for-test-fi.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-007",
      "title": "Parity Tests Prevent Test Double Drift",
      "tags": [
        "testing",
        "patterns",
        "parity",
        "test-doubles",
        "contracts"
      ],
      "created": "2026-02-09T06:33:20.272780Z",
      "source": "v004/01-test-foundation, 02-blackbox-contract/003-search-unification",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Parity tests running identical operations against InMemory fakes and real implementations catch behavioral drift automatically.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-007-parity-tests-prevent-test-double-drift.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-008",
      "title": "Record-Replay with Strict Mode for External Dependency Testing",
      "tags": [
        "testing",
        "patterns",
        "record-replay",
        "external-dependencies",
        "contracts"
      ],
      "created": "2026-02-09T06:33:29.168741Z",
      "source": "v004/02-blackbox-contract/002-ffmpeg-contract-tests",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Three-tier executor pattern (Real/Recording/Fake) with strict argument verification enables reliable testing of external dependencies.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-008-record-replay-with-strict-mode-for-external-depend.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-009",
      "title": "Handler Registration Pattern for Generic Job Queues",
      "tags": [
        "architecture",
        "patterns",
        "job-queue",
        "dependency-injection"
      ],
      "created": "2026-02-09T06:33:43.143756Z",
      "source": "v004/03-async-scan/001-job-queue-infrastructure",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Explicit handler registration with factory-based dependency injection provides clean, testable job routing without global state.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-009-handler-registration-pattern-for-generic-job-queue.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-010",
      "title": "Prefer stdlib asyncio.Queue over External Queue Dependencies",
      "tags": [
        "architecture",
        "asyncio",
        "dependencies",
        "simplicity"
      ],
      "created": "2026-02-09T06:33:52.433360Z",
      "source": "v004/03-async-scan (cross-theme learning)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "stdlib asyncio.Queue with producer-consumer pattern eliminates external queue dependencies while meeting single-worker requirements.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-010-prefer-stdlib-asyncio-queue-over-external-queue-de.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-011",
      "title": "Python Business Logic, Rust Input Safety in Hybrid Architectures",
      "tags": [
        "architecture",
        "rust",
        "python",
        "hybrid",
        "security",
        "boundaries"
      ],
      "created": "2026-02-09T06:34:03.991539Z",
      "source": "v004/04-security-performance (cross-theme learning)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "In hybrid Python/Rust architectures, Rust handles input sanitization and type safety while Python handles business policy and domain rules.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-011-python-business-logic-rust-input-safety-in-hybrid-.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-012",
      "title": "PyO3 FFI Overhead Makes Rust Slower for Simple Operations",
      "tags": [
        "performance",
        "rust",
        "pyo3",
        "ffi",
        "benchmarking"
      ],
      "created": "2026-02-09T06:34:13.655405Z",
      "source": "v004/04-security-performance/002-performance-benchmark",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "PyO3 FFI overhead makes Rust 7-10x slower than Python for simple operations; Rust wins only for string-heavy processing (1.9x faster).",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-012-pyo3-ffi-overhead-makes-rust-slower-for-simple-ope.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-013",
      "title": "Progressive Coverage Thresholds for Bootstrapping Enforcement",
      "tags": [
        "ci",
        "coverage",
        "process",
        "thresholds"
      ],
      "created": "2026-02-09T06:34:22.507319Z",
      "source": "v004/05-devex-coverage/002-rust-coverage",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Start with conservative coverage thresholds and ratchet up after confirming baseline, avoiding false CI failures during initial enforcement.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-013-progressive-coverage-thresholds-for-bootstrapping-.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-014",
      "title": "Template-Driven Process Improvements Over Standalone Documentation",
      "tags": [
        "process",
        "templates",
        "documentation",
        "adoption"
      ],
      "created": "2026-02-09T06:34:37.018232Z",
      "source": "v004/05-devex-coverage/001-property-test-guidance",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Embed process improvements directly into existing templates rather than standalone docs to ensure adoption in standard workflows.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-014-template-driven-process-improvements-over-standalo.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-015",
      "title": "Single-Matrix CI Jobs for Expensive Operations",
      "tags": [
        "ci",
        "performance",
        "process",
        "github-actions"
      ],
      "created": "2026-02-09T06:34:47.073555Z",
      "source": "v004/05-devex-coverage/002-rust-coverage",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Run expensive CI operations on a single platform in separate jobs rather than across the full test matrix to keep CI fast.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-015-single-matrix-ci-jobs-for-expensive-operations.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-016",
      "title": "Validate Acceptance Criteria Against Codebase During Design",
      "tags": [
        "process",
        "design",
        "requirements",
        "validation"
      ],
      "created": "2026-02-09T06:34:56.481858Z",
      "source": "v004/01-test-foundation/003-fixture-factory, version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Validate that acceptance criteria reference existing domain models and APIs during design phase to prevent unachievable requirements during execution.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-016-validate-acceptance-criteria-against-codebase-duri.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-017",
      "title": "Empty Allowlist Means Unrestricted as Backwards-Compatible Default",
      "tags": [
        "security",
        "configuration",
        "backwards-compatibility",
        "patterns"
      ],
      "created": "2026-02-09T06:35:04.869022Z",
      "source": "v004/04-security-performance/001-security-audit",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Empty allowlist defaulting to unrestricted preserves backwards compatibility while letting production environments lock down access explicitly.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-017-empty-allowlist-means-unrestricted-as-backwards-co.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-018",
      "title": "Audit-Then-Fix Is More Efficient Than Blanket Changes",
      "tags": [
        "process",
        "code-quality",
        "auditing",
        "pragmatism"
      ],
      "created": "2026-02-09T06:35:14.543926Z",
      "source": "v004/05-devex-coverage/003-coverage-gap-fixes",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Catalogue all suppressions first, evaluate justification, then fix only unjustified ones \u2014 prevents unnecessary churn from blanket changes.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-018-audit-then-fix-is-more-efficient-than-blanket-chan.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-019",
      "title": "Build Infrastructure First in Sequential Version Planning",
      "tags": [
        "process",
        "planning",
        "architecture",
        "sequencing"
      ],
      "created": "2026-02-09T06:35:28.304735Z",
      "source": "v004 version retrospective (cross-theme learning)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Sequence infrastructure themes before consumer themes in version planning; the upfront investment pays off when subsequent themes consume the infrastructure.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-019-build-infrastructure-first-in-sequential-version-p.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-020",
      "title": "Conditional Static Mount Pattern for Optional Frontend Serving",
      "tags": [
        "fastapi",
        "patterns",
        "testing",
        "frontend",
        "static-files"
      ],
      "created": "2026-02-09T18:54:06.211262Z",
      "source": "v005/01-frontend-foundation, v005/04-e2e-testing",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Only mount StaticFiles when the directory exists to decouple backend testing from frontend build state; auto-load from settings for seamless production serving.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-020-conditional-static-mount-pattern-for-optional-fron.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-021",
      "title": "Separate Vitest Config for Vite 7+ Projects",
      "tags": [
        "frontend",
        "vite",
        "vitest",
        "typescript",
        "configuration"
      ],
      "created": "2026-02-09T18:54:14.315152Z",
      "source": "v005/01-frontend-foundation/001-frontend-scaffolding",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Vite 7 + Vitest 4 require separate vitest.config.ts; inline test config in vite.config.ts causes TypeScript errors.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-021-separate-vitest-config-for-vite-7-projects.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-022",
      "title": "Automated Accessibility Testing Catches Real Violations",
      "tags": [
        "accessibility",
        "testing",
        "e2e",
        "playwright",
        "wcag"
      ],
      "created": "2026-02-09T18:54:23.874701Z",
      "source": "v005/04-e2e-testing/002-e2e-test-suite",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Automated axe-core accessibility checks in E2E tests catch real WCAG violations cheaply; include them from the start rather than retrofitting.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-022-automated-accessibility-testing-catches-real-viola.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-023",
      "title": "Client-Side Navigation for SPA E2E Tests Without Server-Side Routing",
      "tags": [
        "e2e",
        "testing",
        "spa",
        "routing",
        "playwright"
      ],
      "created": "2026-02-09T18:54:34.266089Z",
      "source": "v005/04-e2e-testing/002-e2e-test-suite",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "SPA E2E tests must use client-side navigation (clicking UI elements) from root path when the server doesn't handle SPA fallback routing for sub-paths.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-023-client-side-navigation-for-spa-e2e-tests-without-s.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-024",
      "title": "Focused Zustand Stores Over Monolithic State Management",
      "tags": [
        "frontend",
        "react",
        "state-management",
        "zustand",
        "patterns"
      ],
      "created": "2026-02-09T18:54:45.662195Z",
      "source": "v005/03-gui-components (cross-theme pattern)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Use multiple focused Zustand stores scoped to feature domains with bounded eviction policies for lightweight, testable state management in React apps.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-024-focused-zustand-stores-over-monolithic-state-manag.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-025",
      "title": "Feature Handoff Documents Enable Zero-Rework Sequencing",
      "tags": [
        "process",
        "sequencing",
        "handoff",
        "documentation",
        "patterns"
      ],
      "created": "2026-02-09T18:54:55.806218Z",
      "source": "v005 version retrospective (cross-theme learning)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Feature handoff documents communicating integration points and patterns enable zero-rework feature chains when combined with correct sequencing.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-025-feature-handoff-documents-enable-zero-rework-seque.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-026",
      "title": "Opt-In Validation Preserves Backward Compatibility",
      "tags": [
        "pattern",
        "backward-compatibility",
        "validation",
        "api-design"
      ],
      "created": "2026-02-19T07:01:21.665270Z",
      "source": "v006/01-filter-engine/002-graph-validation completion-report, v006/01-filter-engine retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Make new validation opt-in via explicit methods rather than modifying existing behavior, so existing consumers continue working unchanged.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-026-opt-in-validation-preserves-backward-compatibility.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-027",
      "title": "Property-Based Testing Catches Serialization Edge Cases",
      "tags": [
        "pattern",
        "testing",
        "proptest",
        "serialization",
        "rust"
      ],
      "created": "2026-02-19T07:01:33.286883Z",
      "source": "v006/01-filter-engine/001-expression-engine completion-report, v006/02-filter-builders/002-speed-builders completion-report, v006 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Property-based testing catches serialization edge cases (balanced parentheses, invalid values, boundary conditions) that hand-written unit tests miss, at low marginal cost.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-027-property-based-testing-catches-serialization-edge-.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-028",
      "title": "Repeatable Implementation Templates Across Feature Series",
      "tags": [
        "process",
        "pattern",
        "templates",
        "scaling",
        "consistency"
      ],
      "created": "2026-02-19T07:01:41.589254Z",
      "source": "v006/01-filter-engine retrospective, v006/02-filter-builders retrospective, v006 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Establishing a consistent implementation template in the first feature of a series accelerates all subsequent features and reduces error rates.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-028-repeatable-implementation-templates-across-feature.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-029",
      "title": "Conscious Simplicity with Documented Upgrade Paths",
      "tags": [
        "decision-framework",
        "architecture",
        "yagni",
        "simplicity",
        "trade-offs"
      ],
      "created": "2026-02-19T07:01:58.865273Z",
      "source": "v006/03-effects-api retrospective, v006 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Choose the simplest implementation for current scope but document explicit upgrade triggers; conscious simplicity with a documented threshold is a design decision, not technical debt.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-029-conscious-simplicity-with-documented-upgrade-paths.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-030",
      "title": "Architecture Documentation as an Explicit Feature Deliverable",
      "tags": [
        "process",
        "documentation",
        "architecture",
        "api-design",
        "quality"
      ],
      "created": "2026-02-19T07:02:10.323829Z",
      "source": "v006/03-effects-api/003-architecture-docs completion-report, v006/03-effects-api retrospective, v006 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Dedicate an explicit feature to architecture documentation updates after implementation, ensuring docs stay in lockstep with code and catching API spec discrepancies.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-030-architecture-documentation-as-an-explicit-feature-.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-031",
      "title": "Detailed Design Specifications Correlate with First-Iteration Success",
      "tags": [
        "process",
        "design",
        "requirements",
        "planning",
        "quality"
      ],
      "created": "2026-02-19T07:02:20.720023Z",
      "source": "v006 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Detailed design specs with specific acceptance criteria, implementation plans, and scope boundaries lead to first-iteration feature success with no rework.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-031-detailed-design-specifications-correlate-with-firs.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-032",
      "title": "Schema-Driven Architecture Enables Backend-to-Frontend Consistency",
      "tags": [
        "pattern",
        "architecture",
        "schema",
        "frontend",
        "backend"
      ],
      "created": "2026-02-19T23:22:52.815000Z",
      "source": "v007 cross-theme (T02-effect-registry-api/T03-effect-workshop-gui)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Define data schemas once in the backend and use them to drive frontend UI generation, eliminating hardcoded components and ensuring consistent validation at both layers.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-032-schema-driven-architecture-enables-backend-to-fron.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-033",
      "title": "Fix CI Reliability Before Dependent Development Cycles",
      "tags": [
        "process",
        "ci",
        "reliability",
        "planning",
        "failure-mode"
      ],
      "created": "2026-02-19T23:23:04.800386Z",
      "source": "v007/03-effect-workshop-gui retrospective, v007/04-quality-validation retrospective, v007 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Fix CI reliability issues before starting development cycles that depend on CI for PR merges; a single flaky test can block multiple features and themes.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-033-fix-ci-reliability-before-dependent-development-cy.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-034",
      "title": "Validate Numeric Requirements Against Upstream Sources During Design",
      "tags": [
        "process",
        "requirements",
        "design",
        "validation",
        "decision-framework"
      ],
      "created": "2026-02-19T23:23:16.386938Z",
      "source": "v007/01-rust-filter-builders retrospective, v007/01-rust-filter-builders/002-transition-filter-builders completion-report",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Cross-check numeric claims in requirements against upstream source documentation during design to avoid spec-vs-reality mismatches during implementation.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-034-validate-numeric-requirements-against-upstream-sou.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-035",
      "title": "Automate Manual Maintenance When Third Instance Appears",
      "tags": [
        "process",
        "tooling",
        "maintenance",
        "automation",
        "decision-framework"
      ],
      "created": "2026-02-19T23:23:29.214293Z",
      "source": "v007/01-rust-filter-builders retrospective, v007 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Apply the rule of three to manual maintenance tasks: automate when the third instance appears, and set the threshold explicitly at the first instance.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-035-automate-manual-maintenance-when-third-instance-ap.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-036",
      "title": "Debounced Stateless Preview Endpoints for Real-Time UI",
      "tags": [
        "pattern",
        "api-design",
        "frontend",
        "performance",
        "ux"
      ],
      "created": "2026-02-19T23:23:41.015401Z",
      "source": "v007/03-effect-workshop-gui/003-live-filter-preview completion-report, v007/03-effect-workshop-gui retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Combine a stateless backend preview endpoint with client-side debouncing (200-300ms) for responsive real-time UI previews without API flooding.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-036-debounced-stateless-preview-endpoints-for-real-tim.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-037",
      "title": "Feature Composition Succeeds Through Independent Store Interfaces",
      "tags": [
        "pattern",
        "frontend",
        "architecture",
        "composability",
        "zustand"
      ],
      "created": "2026-02-19T23:23:52.919238Z",
      "source": "v007/03-effect-workshop-gui retrospective, v007 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Design each feature as a standalone component with an independent state store and clean interface; composition features can then orchestrate without modifying internals.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-037-feature-composition-succeeds-through-independent-s.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-038",
      "title": "Sub-Agent File Operations Fail When Read-Before-Write Is Skipped",
      "tags": [
        "process",
        "tooling",
        "sub-agents",
        "failure-mode",
        "session-health"
      ],
      "created": "2026-02-19T23:24:06.282122Z",
      "source": "session analytics (v007 period)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Sub-agents frequently fail with 'file not read' errors when attempting Write/Edit without prior Read; include explicit read-first instructions in sub-agent prompts.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-038-sub-agent-file-operations-fail-when-read-before-wr.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-039",
      "title": "Excessive Context Compaction Signals Need for Task Decomposition",
      "tags": [
        "process",
        "session-health",
        "context-management",
        "decomposition",
        "efficiency"
      ],
      "created": "2026-02-19T23:24:17.662930Z",
      "source": "session analytics (v007 period), v007 session health findings",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "48% of sessions hit 3+ context compaction events; decompose large tasks, use targeted reads, and summarize intermediate results to reduce context churn.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-039-excessive-context-compaction-signals-need-for-task.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-040",
      "title": "Idempotent Startup Functions for Lifespan Wiring",
      "tags": [
        "pattern",
        "startup",
        "idempotency",
        "fastapi",
        "lifespan"
      ],
      "created": "2026-02-22T10:48:03.307911Z",
      "source": "v008/01-application-startup-wiring retrospective, v008/01-application-startup-wiring/001-database-startup completion-report, v008/01-application-startup-wiring/002-logging-startup completion-report",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Startup/lifespan functions must be idempotent using operation-appropriate guards (IF NOT EXISTS, handler dedup, init flags) to prevent side-effect accumulation in tests and production.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-040-idempotent-startup-functions-for-lifespan-wiring.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-041",
      "title": "Static Type Checking Catches Cross-Module Wiring Errors",
      "tags": [
        "pattern",
        "mypy",
        "type-checking",
        "wiring",
        "debugging"
      ],
      "created": "2026-02-22T10:48:14.385048Z",
      "source": "v008/01-application-startup-wiring/003-orphaned-settings completion-report, v008 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "mypy catches invalid API calls during cross-module wiring work (e.g., wrong kwargs on framework functions) before runtime, acting as design feedback on implementation plans.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-041-static-type-checking-catches-cross-module-wiring-e.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-042",
      "title": "Group Features by Modification Point for Theme Cohesion",
      "tags": [
        "process",
        "planning",
        "theme-design",
        "cohesion",
        "efficiency"
      ],
      "created": "2026-02-22T10:48:23.768383Z",
      "source": "v008/01-application-startup-wiring retrospective, v008 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Group features that modify the same code path into a single theme to reduce context-switching and enable knowledge compounding across features.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-042-group-features-by-modification-point-for-theme-coh.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-043",
      "title": "Explicit Assertion Timeouts in CI-Bound E2E Tests",
      "tags": [
        "testing",
        "e2e",
        "playwright",
        "ci",
        "reliability",
        "failure-mode"
      ],
      "created": "2026-02-22T10:48:35.116707Z",
      "source": "v008/02-ci-stability/001-flaky-e2e-fix completion-report, v008/02-ci-stability retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Add explicit timeouts to all state-transition assertions in E2E specs; default Playwright timeouts cause intermittent CI failures in slower GitHub Actions environments.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-043-explicit-assertion-timeouts-in-ci-bound-e2e-tests.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-044",
      "title": "Settings Consumer Traceability as a Completeness Check",
      "tags": [
        "pattern",
        "configuration",
        "settings",
        "completeness",
        "maintenance"
      ],
      "created": "2026-02-22T10:48:48.897027Z",
      "source": "v008/01-application-startup-wiring/003-orphaned-settings completion-report, v008/01-application-startup-wiring retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Verify every settings field has a production consumer after wiring work; orphaned settings indicate incomplete wiring and create operator confusion.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-044-settings-consumer-traceability-as-a-completeness-c.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-045",
      "title": "Single-Feature Themes for Precisely-Scoped Bug Fixes",
      "tags": [
        "process",
        "planning",
        "theme-design",
        "bug-fixes",
        "scoping"
      ],
      "created": "2026-02-22T10:48:59.922932Z",
      "source": "v008/02-ci-stability retrospective, v008 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Isolate bug fixes as single-feature themes with their own acceptance criteria rather than bundling into unrelated themes; keeps scope clear and review trivial.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-045-single-feature-themes-for-precisely-scoped-bug-fix.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-046",
      "title": "Maintenance Versions Succeed with Well-Understood Change Scoping",
      "tags": [
        "process",
        "planning",
        "scoping",
        "maintenance",
        "quality"
      ],
      "created": "2026-02-22T10:49:10.299313Z",
      "source": "v008 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Maintenance-focused versions with well-understood changes achieve higher first-iteration success; dedicate versions to maintenance when debt inventory justifies it.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-046-maintenance-versions-succeed-with-well-understood-.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-047",
      "title": "WAL Mode Enables Safe Mixed Sync/Async SQLite Access",
      "tags": [
        "pattern",
        "sqlite",
        "async",
        "database",
        "concurrency"
      ],
      "created": "2026-02-22T17:52:50.081379Z",
      "source": "v009/01-observability-pipeline/002-audit-logging completion-report, v009/01-observability-pipeline retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Open a separate sync sqlite3 connection with WAL mode alongside aiosqlite for safe concurrent sync/async access to the same database without deadlocks.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-047-wal-mode-enables-safe-mixed-sync-async-sqlite-acce.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-048",
      "title": "Catch-All Routes Replace StaticFiles for SPA Fallback in FastAPI",
      "tags": [
        "pattern",
        "fastapi",
        "spa",
        "routing",
        "frontend"
      ],
      "created": "2026-02-22T17:53:02.594672Z",
      "source": "v009/02-gui-runtime-fixes/001-spa-routing completion-report, v009/02-gui-runtime-fixes retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Replace FastAPI StaticFiles mounts with catch-all route handlers that check for static files before falling back to index.html for SPA routing support.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-048-catch-all-routes-replace-staticfiles-for-spa-fallb.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-049",
      "title": "Guard Optional Broadcast Calls to Avoid Runtime Crashes",
      "tags": [
        "pattern",
        "websocket",
        "dependency-injection",
        "defensive-coding",
        "testing"
      ],
      "created": "2026-02-22T17:53:12.146695Z",
      "source": "v009/02-gui-runtime-fixes/003-websocket-broadcasts completion-report, v009/02-gui-runtime-fixes retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Guard optional broadcast/notification calls with if-checks so they become no-ops when the infrastructure is absent, decoupling events from core functionality.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-049-guard-optional-broadcast-calls-to-avoid-runtime-cr.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-050",
      "title": "Incremental DI Wiring Is Fast and Low-Risk When Patterns Are Established",
      "tags": [
        "pattern",
        "dependency-injection",
        "process",
        "planning",
        "efficiency"
      ],
      "created": "2026-02-22T17:53:25.446668Z",
      "source": "v009/01-observability-pipeline retrospective, v009 version retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Wiring existing code into an established DI chain is fast and low-risk; batch similar wiring tasks into dedicated themes for compounding efficiency.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-050-incremental-di-wiring-is-fast-and-low-risk-when-pa.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-051",
      "title": "Add count() to Repository Protocols for Accurate Pagination",
      "tags": [
        "pattern",
        "repository",
        "pagination",
        "api-design",
        "database"
      ],
      "created": "2026-02-22T17:53:35.926003Z",
      "source": "v009/02-gui-runtime-fixes/002-pagination-fix completion-report, v009/02-gui-runtime-fixes retrospective",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Add count() to repository protocols for accurate pagination totals; implement as SELECT COUNT(*) in SQLite and len() in InMemory to avoid returning page size as total.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-051-add-count-to-repository-protocols-for-accurate-pag.md",
      "status": "active",
      "updated_at": null
    },
    {
      "id": "LRN-052",
      "title": "Run Formatter Before Linter to Avoid Double Fix Cycles",
      "tags": [
        "process",
        "tooling",
        "ruff",
        "code-quality",
        "efficiency"
      ],
      "created": "2026-02-22T17:53:47.033681Z",
      "source": "session analytics (v009 period)",
      "source_type": "manual",
      "related_backlog": null,
      "summary": "Run ruff format before ruff check to eliminate format-induced linter violations and reduce fix-and-rerun cycles during quality gate verification.",
      "content_path": "docs/auto-dev/LEARNINGS/LRN-052-run-formatter-before-linter-to-avoid-double-fix-cy.md",
      "status": "active",
      "updated_at": null
    }
  ],
  "next_id": 53
}
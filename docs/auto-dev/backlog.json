{
  "next_id": 80,
  "updated_at": "2026-02-25T11:42:18.190721",
  "items": [
    {
      "id": "BL-001",
      "title": "EXP-001: PyO3/maturin hybrid build workflow investigation",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-01-25T14:30:12.374239",
      "completed_at": null,
      "tags": [
        "investigation",
        "v001-prerequisite",
        "rust",
        "tooling"
      ],
      "description": "Before designing v001, investigate the PyO3/maturin hybrid build chain:\n\n- How does the dev workflow actually function? (edit Rust, rebuild, import in Python)\n- What's the compile time impact?\n- How do we generate and maintain .pyi stub files?\n- What CI configuration is needed for hybrid builds?\n- Are there gotchas with maturin develop vs maturin build?\n\nThis informs Milestone 1.1 (project setup) and 1.2-1.3 (Rust core).",
      "acceptance_criteria": [
        {
          "text": "Exploration documents hybrid Python+Rust build workflow",
          "done": false
        },
        {
          "text": "Dev experience documented (edit-compile-test cycle)",
          "done": false
        },
        {
          "text": "CI setup requirements identified",
          "done": false
        },
        {
          "text": "Type stub (.pyi) generation process documented",
          "done": false
        }
      ],
      "notes": "Exploration complete. Results in comms/outbox/exploration/rust-python-hybrid/",
      "use_case": "This feature addresses: EXP-001: PyO3/maturin hybrid build workflow investigation. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null,
      "upvotes": 0
    },
    {
      "id": "BL-002",
      "title": "EXP-002: Recording fake pattern for FFmpeg executor",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-01-25T14:30:20.472748",
      "completed_at": null,
      "tags": [
        "investigation",
        "v001-prerequisite",
        "testing",
        "ffmpeg"
      ],
      "description": "Investigate the recording fake pattern for FFmpeg integration testing:\n\n- How does RecordingFFmpegExecutor capture commands?\n- How do we verify captured commands against expected FFmpeg syntax?\n- What's the contract test pattern \u2014 run against real FFmpeg periodically?\n- How does this integrate with the black box testing harness?\n\nThis informs v001 (basic structure) and v004 (full testing infrastructure).",
      "acceptance_criteria": [
        {
          "text": "Concrete RecordingFFmpegExecutor implementation documented",
          "done": false
        },
        {
          "text": "Recording/playback mechanism for command verification explained",
          "done": false
        },
        {
          "text": "Contract test pattern for FFmpeg commands demonstrated",
          "done": false
        },
        {
          "text": "Integration with pytest fixtures shown",
          "done": false
        }
      ],
      "notes": "Exploration complete. Results in comms/outbox/exploration/recording-fake-pattern/",
      "use_case": "This feature addresses: EXP-002: Recording fake pattern for FFmpeg executor. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null,
      "upvotes": 0
    },
    {
      "id": "BL-003",
      "title": "EXP-003: FastAPI static file serving for GUI",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-25T14:30:30.773235",
      "completed_at": "2026-02-09T18:43:01.140225",
      "tags": [
        "investigation",
        "v005-prerequisite",
        "gui",
        "fastapi"
      ],
      "description": "Investigate serving the React/Svelte GUI from FastAPI:\n\n- How do we configure FastAPI to serve static files from Vite build output?\n- What's the development workflow \u2014 proxy setup for hot reload?\n- How do we handle the /gui/* route mounting?\n- What about index.html fallback for SPA routing?\n\nThis informs v005 (GUI shell).",
      "acceptance_criteria": [
        {
          "text": "FastAPI StaticFiles mount configuration documented",
          "done": false
        },
        {
          "text": "Vite build output integration explained",
          "done": false
        },
        {
          "text": "Development workflow (hot reload) documented",
          "done": false
        },
        {
          "text": "Production deployment pattern shown",
          "done": false
        }
      ],
      "notes": "Use case: A developer sets up the v005 GUI integration and needs to know how FastAPI will serve the Vite-built frontend bundle, how SPA client-side routing will work with server-side fallback, and what the dev workflow looks like with hot module replacement proxied through FastAPI.",
      "use_case": "This feature addresses: EXP-003: FastAPI static file serving for GUI. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "frontend-foundation",
      "upvotes": 0
    },
    {
      "id": "BL-004",
      "title": "Expose Clip and ValidationError types to Python",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:15:52.979456",
      "completed_at": "2026-01-28T07:46:02.471405",
      "tags": [
        "python-bindings",
        "v002",
        "rust",
        "pyo3"
      ],
      "description": "Theme 02 (timeline-math) implemented Clip and ValidationError types in Rust but noted \"PyO3 bindings not yet added\". These types need to be exposed to Python with full type stubs.",
      "acceptance_criteria": [
        {
          "text": "Clip type exposed to Python with all methods",
          "done": false
        },
        {
          "text": "ValidationError exposed with field, message, actual, expected attributes",
          "done": false
        },
        {
          "text": "Type stubs updated in stubs/stoat_ferret_core/",
          "done": false
        },
        {
          "text": "Integration tests verify round-trip behavior",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Expose Clip and ValidationError types to Python. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "01-rust-python-bindings",
      "upvotes": 0
    },
    {
      "id": "BL-005",
      "title": "Expose TimeRange and list operations to Python",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:15:58.874332",
      "completed_at": "2026-01-28T07:45:01.464881",
      "tags": [
        "python-bindings",
        "v002",
        "rust",
        "pyo3"
      ],
      "description": "Theme 02 (timeline-math) implemented TimeRange with set operations and list operations in Rust but noted these are \"not yet exposed to Python\". Critical for Python-side timeline manipulation.",
      "acceptance_criteria": [
        {
          "text": "TimeRange type exposed to Python with half-open interval semantics",
          "done": false
        },
        {
          "text": "Set operations (overlap, intersection, union, subtraction, contains) available",
          "done": false
        },
        {
          "text": "List operations (find_gaps, merge_ranges) available",
          "done": false
        },
        {
          "text": "Type stubs updated",
          "done": false
        },
        {
          "text": "Integration tests verify all operations",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Expose TimeRange and list operations to Python. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "01-rust-python-bindings",
      "upvotes": 0
    },
    {
      "id": "BL-006",
      "title": "Update AGENTS.md with PyO3 bindings guidance",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:05.360801",
      "completed_at": "2026-01-28T07:45:04.497597",
      "tags": [
        "process",
        "documentation",
        "pyo3"
      ],
      "description": "v001 retrospective identified that deferring PyO3 bindings created tech debt. AGENTS.md should instruct Claude Code to add Python bindings incrementally in the same feature that implements the Rust types, rather than deferring to a later feature.",
      "acceptance_criteria": [
        {
          "text": "AGENTS.md includes section on PyO3 bindings best practices",
          "done": false
        },
        {
          "text": "Guidance states: add Python bindings in same feature as Rust implementation",
          "done": false
        },
        {
          "text": "Guidance states: do not defer bindings to a later feature",
          "done": false
        },
        {
          "text": "Example provided showing correct incremental approach",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Update AGENTS.md with PyO3 bindings guidance. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "02-tooling-process",
      "upvotes": 0
    },
    {
      "id": "BL-007",
      "title": "Automate type stub generation in CI",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:11.387037",
      "completed_at": "2026-01-28T07:46:13.695335",
      "tags": [
        "tooling",
        "ci",
        "pyo3",
        "type-stubs"
      ],
      "description": "Type stubs in stubs/stoat_ferret_core/ are manually maintained. This can drift from the actual Rust API. Automate stub generation in CI to catch drift early.",
      "acceptance_criteria": [
        {
          "text": "pyo3-stub-gen or equivalent generates stubs automatically",
          "done": false
        },
        {
          "text": "CI step verifies generated stubs match committed stubs",
          "done": false
        },
        {
          "text": "CI fails if stubs are out of sync with Rust API",
          "done": false
        },
        {
          "text": "Documentation on how to regenerate stubs",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Automate type stub generation in CI. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "01-rust-python-bindings",
      "upvotes": 0
    },
    {
      "id": "BL-008",
      "title": "Clean up Python API naming inconsistencies",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:17.330873",
      "completed_at": "2026-01-28T07:46:17.287788",
      "tags": [
        "api",
        "cleanup",
        "pyo3"
      ],
      "description": "v001 retrospective noted some Python methods have `py_` prefixes or different names than their Rust counterparts. This creates API inconsistency. Clean up naming to be consistent across languages where possible.",
      "acceptance_criteria": [
        {
          "text": "Audit all Python methods for py_ prefixes",
          "done": false
        },
        {
          "text": "Remove unnecessary py_ prefixes where Rust and Python names can match",
          "done": false
        },
        {
          "text": "Document any intentional naming differences",
          "done": false
        },
        {
          "text": "Update type stubs to match",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Clean up Python API naming inconsistencies. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "01-rust-python-bindings",
      "upvotes": 0
    },
    {
      "id": "BL-009",
      "title": "Add property test guidance to feature design template",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:23.472478",
      "completed_at": "2026-02-09T06:28:42.861436",
      "tags": [
        "process",
        "testing",
        "proptest",
        "v004"
      ],
      "description": "v001 retrospective suggested writing proptest invariants before implementation as executable specifications. Add guidance to feature design templates encouraging this pattern, along with tracking expected test counts.",
      "acceptance_criteria": [
        {
          "text": "Feature design template includes property test section",
          "done": false
        },
        {
          "text": "Guidance on writing proptest invariants before implementation",
          "done": false
        },
        {
          "text": "Example showing invariant-first design approach",
          "done": false
        },
        {
          "text": "Documentation on expected test count tracking",
          "done": false
        }
      ],
      "notes": "Use case: A developer designing a new Rust type (e.g., AudioMixer) opens the feature design template and sees a property test section. Following the guidance, they write proptest invariants first \u2014 \"mixing two silent tracks produces silence\", \"output duration equals longest input\" \u2014 then implement the type to satisfy them. The invariants serve as executable specifications that catch edge cases unit tests would miss.",
      "use_case": "This feature addresses: Add property test guidance to feature design template. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "devex-coverage",
      "upvotes": 0
    },
    {
      "id": "BL-010",
      "title": "Configure Rust code coverage with llvm-cov",
      "priority": "P3",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:28.865973",
      "completed_at": "2026-02-09T06:28:43.978905",
      "tags": [
        "testing",
        "coverage",
        "rust",
        "ci",
        "v004"
      ],
      "description": "v001 retrospective noted Rust code coverage is not tracked. Configure llvm-cov to measure and report Rust test coverage alongside Python coverage.",
      "acceptance_criteria": [
        {
          "text": "llvm-cov configured for Rust workspace",
          "done": false
        },
        {
          "text": "Coverage reports generated during CI",
          "done": false
        },
        {
          "text": "Coverage threshold enforced (e.g., 80%)",
          "done": false
        },
        {
          "text": "Coverage visible in CI artifacts or dashboard",
          "done": false
        }
      ],
      "notes": "Use case: After merging a PR that adds new Rust code, the CI pipeline runs llvm-cov and reports that Rust coverage dropped from 92% to 85%. The developer sees the uncovered lines in the CI artifact, adds tests for the missing paths, and pushes a fix \u2014 maintaining the 90% threshold before the PR can merge.",
      "use_case": "This feature addresses: Configure Rust code coverage with llvm-cov. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "devex-coverage",
      "upvotes": 0
    },
    {
      "id": "BL-011",
      "title": "Consolidate Python/Rust build backends",
      "priority": "P3",
      "status": "cancelled",
      "size": "m",
      "added": "2026-01-26T17:16:34.152027",
      "completed_at": null,
      "tags": [
        "tooling",
        "build",
        "complexity"
      ],
      "description": "v001 uses hatchling for Python package management and maturin for Rust/PyO3 builds. This dual-backend approach adds complexity. Evaluate whether the build system can be simplified.",
      "acceptance_criteria": [
        {
          "text": "Evaluate if hatchling + maturin can be unified",
          "done": false
        },
        {
          "text": "Document build system architecture and rationale",
          "done": false
        },
        {
          "text": "Simplify if possible without breaking functionality",
          "done": false
        },
        {
          "text": "Update developer documentation",
          "done": false
        }
      ],
      "notes": "Obsoleted by 7 versions of successful dual-backend usage. The hatchling + maturin pattern is the correct approach for PyO3 hybrid projects \u2014 consolidation isn't feasible without tradeoffs that aren't worth it.",
      "use_case": "This feature addresses: Consolidate Python/Rust build backends. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null,
      "upvotes": 0
    },
    {
      "id": "BL-012",
      "title": "Fix coverage reporting gaps for ImportError fallback",
      "priority": "P3",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:39.614208",
      "completed_at": "2026-02-09T06:28:45.186999",
      "tags": [
        "testing",
        "coverage",
        "cleanup",
        "v004"
      ],
      "description": "v001 retrospective noted ImportError fallback code is excluded from coverage. Review all coverage exclusions and ensure they are intentional and documented.",
      "acceptance_criteria": [
        {
          "text": "Identify all coverage exclusions in Python code",
          "done": false
        },
        {
          "text": "Remove or justify each exclusion",
          "done": false
        },
        {
          "text": "ImportError fallback properly tested or documented as intentional exclusion",
          "done": false
        },
        {
          "text": "Coverage threshold maintained",
          "done": false
        }
      ],
      "notes": "Use case: A developer notices the coverage report shows 93% but suspects some lines are excluded via pragmas. They audit all # pragma: no cover comments and find the ImportError fallback for the Rust extension is excluded but could be tested by running without the compiled module. After removing unjustified exclusions and adding targeted tests, the coverage number reflects actual test quality.",
      "use_case": "This feature addresses: Fix coverage reporting gaps for ImportError fallback. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "devex-coverage",
      "upvotes": 0
    },
    {
      "id": "BL-013",
      "title": "Add async repository implementation for FastAPI (aiosqlite)",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-28T09:26:37.042060",
      "completed_at": "2026-01-28T22:37:18.032534Z",
      "tags": [
        "database",
        "async",
        "v003",
        "tech-debt"
      ],
      "description": "v002 retrospective identified that synchronous SQLite will need to be replaced with aiosqlite when FastAPI is introduced in v003. The repository pattern is already in place, so this is a straightforward implementation swap.",
      "acceptance_criteria": [
        {
          "text": "AsyncVideoRepository protocol defined",
          "done": true
        },
        {
          "text": "aiosqlite implementation created",
          "done": true
        },
        {
          "text": "Existing sync repository kept for CLI/scripts",
          "done": true
        },
        {
          "text": "Integration tests verify async behavior",
          "done": true
        }
      ],
      "notes": "Completed in v003/01-process-improvements",
      "use_case": "This feature addresses: Add async repository implementation for FastAPI (aiosqlite). It improves the system by resolving the described requirement.",
      "implemented_in_version": "v003",
      "implemented_in_theme": "01-process-improvements",
      "upvotes": 0
    },
    {
      "id": "BL-014",
      "title": "Add Docker-based local testing option",
      "priority": "P2",
      "status": "completed",
      "size": "s",
      "added": "2026-01-28T09:26:42.609453",
      "completed_at": "2026-02-09T06:28:46.257733",
      "tags": [
        "tooling",
        "docker",
        "process",
        "developer-experience",
        "v004"
      ],
      "description": "v002 retrospective identified that Windows Application Control policies can block local Python testing. A Docker-based option would bypass these restrictions and provide consistent dev environments.",
      "acceptance_criteria": [
        {
          "text": "docker-compose.yml with Python + Rust build environment",
          "done": false
        },
        {
          "text": "README documents Docker-based testing workflow",
          "done": false
        },
        {
          "text": "Tests can run inside container bypassing host restrictions",
          "done": false
        }
      ],
      "notes": "Use case: A contributor on Windows with Application Control policies enabled cannot run pytest locally because the policy blocks Python execution. They run docker-compose up test and the full test suite executes inside a Linux container, bypassing host restrictions and providing the same environment as CI.",
      "use_case": "This feature addresses: Add Docker-based local testing option. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "devex-coverage",
      "upvotes": 0
    },
    {
      "id": "BL-015",
      "title": "Add migration verification to CI (upgrade/downgrade/upgrade)",
      "priority": "P2",
      "status": "completed",
      "size": "s",
      "added": "2026-01-28T09:26:47.388756",
      "completed_at": "2026-01-28T22:37:18.032534Z",
      "tags": [
        "ci",
        "database",
        "migrations",
        "quality"
      ],
      "description": "v002 retrospective suggested adding migration verification to CI to ensure all migrations are fully reversible. Run upgrade/downgrade/upgrade cycle to catch issues early.",
      "acceptance_criteria": [
        {
          "text": "CI runs: alembic upgrade head && alembic downgrade base && alembic upgrade head",
          "done": true
        },
        {
          "text": "CI fails if any migration step fails",
          "done": true
        },
        {
          "text": "Documentation updated with migration testing requirements",
          "done": true
        }
      ],
      "notes": "Completed in v003/01-process-improvements",
      "use_case": "This feature addresses: Add migration verification to CI (upgrade/downgrade/upgrade). It improves the system by resolving the described requirement.",
      "implemented_in_version": "v003",
      "implemented_in_theme": "01-process-improvements",
      "upvotes": 0
    },
    {
      "id": "BL-016",
      "title": "Unify InMemory vs FTS5 search behavior",
      "priority": "P3",
      "status": "completed",
      "size": "s",
      "added": "2026-01-28T09:26:52.286493",
      "completed_at": "2026-02-09T06:28:47.480503",
      "tags": [
        "database",
        "cleanup",
        "testing",
        "consistency",
        "v004"
      ],
      "description": "v002 retrospective noted that InMemoryVideoRepository uses substring match while SQLiteVideoRepository uses FTS5 full-text search. Consider unifying search behavior for consistent testing.",
      "acceptance_criteria": [
        {
          "text": "InMemoryVideoRepository uses same search semantics as SQLite FTS5",
          "done": false
        },
        {
          "text": "Tests verify consistent behavior across implementations",
          "done": false
        },
        {
          "text": "Documentation explains search behavior",
          "done": false
        }
      ],
      "notes": "Use case: A test uses InMemoryVideoRepository and searches for \"sunset beach\". It finds the video because substring match hits. The same test against SQLite with FTS5 would not find it because FTS5 tokenizes differently. This inconsistency means tests pass with the in-memory double but fail in production. Unifying search semantics ensures test results predict production behavior.",
      "use_case": "This feature addresses: Unify InMemory vs FTS5 search behavior. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "blackbox-contract",
      "upvotes": 0
    },
    {
      "id": "BL-017",
      "title": "Optimize CI to skip heavy steps for docs-only commits",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-28T09:50:25.704437",
      "completed_at": "2026-01-28T22:37:18.032534Z",
      "tags": [
        "ci",
        "optimization",
        "developer-experience"
      ],
      "description": "The CI workflow runs full build and test suite even for documentation-only or housekeeping commits (e.g., version closure, changelog updates, exploration archiving). This wastes CI minutes and slows down simple administrative tasks. Implement path-based filtering or commit message detection to skip heavy steps when only docs/config files change.",
      "acceptance_criteria": [
        {
          "text": "CI workflow detects docs-only or housekeeping commits (e.g., chore:, docs: prefixes)",
          "done": true
        },
        {
          "text": "Docs-only commits skip Rust build, Python tests, and other heavy steps",
          "done": true
        },
        {
          "text": "Path filters implemented for src/, rust/, tests/ vs docs/, comms/",
          "done": true
        },
        {
          "text": "Full CI still runs on code changes and PR merges to main",
          "done": true
        }
      ],
      "notes": "Completed in v003/01-process-improvements",
      "use_case": "This feature addresses: Optimize CI to skip heavy steps for docs-only commits. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v003",
      "implemented_in_theme": "01-process-improvements",
      "upvotes": 0
    },
    {
      "id": "BL-018",
      "title": "Create C4 architecture documentation",
      "priority": "P2",
      "status": "completed",
      "size": "s",
      "added": "2026-02-01T18:17:14.220413",
      "completed_at": "2026-02-19T07:09:24.379051",
      "tags": [
        "documentation",
        "architecture",
        "c4"
      ],
      "description": "No C4 architecture documentation currently exists for the project. Establish documentation at appropriate levels (Context, Container, Component, Code) to document the system architecture.",
      "acceptance_criteria": [],
      "notes": "v004 retrospective architecture check (2026-02-09): The primary architecture doc (docs/design/02-architecture.md) was updated during v004 Theme 03 Feature 3 to reflect async scan, job queue, and updated data flows. No additional drift detected in the design docs. However, the v004 version retrospective explicitly notes that C4 documentation was skipped. v004 added: (1) AsyncioJobQueue with handler registration and background worker, (2) GET /api/v1/jobs/{job_id} status endpoint, (3) ALLOWED_SCAN_ROOTS security configuration with validate_scan_path(), (4) InMemory test doubles and create_app() DI pattern, (5) Docker multi-stage build infrastructure, (6) Rust coverage CI enforcement. These components should be captured when C4 documentation is created.\n\nv005 retrospective architecture check (2026-02-09): The design doc (docs/design/02-architecture.md) already includes /ws and /gui endpoint groups and high-level WebSocket/frontend descriptions added during v004. No C4 documentation exists (docs/C4-Documentation/ not found). v005 added significant frontend architecture not yet documented at the component level: (1) React/TypeScript/Vite frontend with Tailwind CSS v4, (2) ConnectionManager for WebSocket with lazy dead-connection cleanup, (3) ThumbnailService with GET /api/v1/videos/{id}/thumbnail endpoint, (4) AsyncVideoRepository.count() protocol method, (5) GUI components: Shell layout, Dashboard panel, Library Browser, Project Manager, (6) Zustand state management with 3 stores (activityStore, libraryStore, projectStore), (7) Playwright E2E testing infrastructure with CI job, (8) New settings: thumbnail_dir, gui_static_path, ws_heartbeat_interval. The design doc captures the high-level architecture correctly but lacks frontend component-level detail. C4 documentation would address this gap comprehensively.",
      "use_case": "This feature addresses: Create C4 architecture documentation. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "architecture-docs",
      "upvotes": 0
    },
    {
      "id": "BL-019",
      "title": "Add Windows bash /dev/null guidance to AGENTS.md and nul to .gitignore",
      "priority": "P3",
      "status": "completed",
      "size": "l",
      "added": "2026-02-06T20:37:40.867158",
      "completed_at": "2026-02-24T10:08:11.127923",
      "tags": [
        "windows",
        "agents-md",
        "gitignore"
      ],
      "description": "Add Windows bash null redirect guidance to AGENTS.md. In bash contexts on Windows (Git Bash / MSYS2), /dev/null is correctly translated to the Windows null device. However, using bare 'nul' \u2014 the native Windows convention \u2014 creates a literal file named 'nul' in the working directory because MSYS interprets it as a filename rather than a device. This has already caused git noise in the project (nul was added to .gitignore as a workaround). AGENTS.md should document this pitfall so developers and AI agents avoid it. The .gitignore half is already done; this item covers only the AGENTS.md documentation.",
      "acceptance_criteria": [
        {
          "text": "AGENTS.md contains a 'Windows (Git Bash)' section under Commands or a new top-level section",
          "done": false
        },
        {
          "text": "Section documents that /dev/null is correct for output redirection in Git Bash on Windows",
          "done": false
        },
        {
          "text": "Section warns against using bare 'nul' which creates a literal file in MSYS/Git Bash",
          "done": false
        },
        {
          "text": "Section includes correct and incorrect usage examples",
          "done": false
        }
      ],
      "notes": "The .gitignore half is already done (nul added to .gitignore). Remaining scope: add Windows bash /dev/null redirect guidance to AGENTS.md.",
      "use_case": "This feature addresses: Add Windows bash /dev/null guidance to AGENTS.md and nul to .gitignore. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v011",
      "implemented_in_theme": "developer-onboarding",
      "upvotes": 0
    },
    {
      "id": "BL-020",
      "title": "Implement InMemory test doubles for Projects and Jobs",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-08T17:56:36.056975",
      "completed_at": "2026-02-09T06:28:48.704164",
      "tags": [
        "v004",
        "testing",
        "test-doubles"
      ],
      "description": "The RecordingFFmpegExecutor test double exists from v002, but InMemoryProjectStorage and InMemoryJobQueue are missing. The 07-quality-architecture.md spec requires these test doubles for black box testing (M1.8), but only InMemoryVideoRepository has been implemented. Without these doubles, integration tests cannot run in isolation from real storage and must use the actual database, making tests slow and non-deterministic.",
      "acceptance_criteria": [
        {
          "text": "InMemoryProjectStorage implements AsyncProjectRepository protocol with deepcopy isolation",
          "done": false
        },
        {
          "text": "InMemoryJobQueue provides synchronous deterministic execution with configurable outcomes",
          "done": false
        },
        {
          "text": "Both doubles include seed helpers for populating test data",
          "done": false
        },
        {
          "text": "Contract tests verify InMemory behavior matches real SQLite implementations",
          "done": false
        }
      ],
      "notes": "Use case: A developer writing integration tests for the project management API needs to verify that creating a project, adding clips, and rendering produces the correct FFmpeg command \u2014 without touching the real database or file system. They instantiate InMemoryProjectStorage and InMemoryJobQueue, seed them with test data, wire them into the app, and assert on outcomes deterministically.",
      "use_case": "This feature addresses: Implement InMemory test doubles for Projects and Jobs. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "test-foundation",
      "upvotes": 0
    },
    {
      "id": "BL-021",
      "title": "Add dependency injection to create_app() for test wiring",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:56:42.085445",
      "completed_at": "2026-02-09T06:28:49.818774",
      "tags": [
        "v004",
        "testing",
        "dependency-injection"
      ],
      "description": "The `create_app()` factory exists but does not accept injectable dependencies as specified in 07-quality-architecture.md. Tests currently cannot swap in recording or in-memory fakes at the application level. This blocks black box testing (M1.8) because there is no way to wire test doubles into the running FastAPI app without monkey-patching.",
      "acceptance_criteria": [
        {
          "text": "create_app() accepts optional executor, repository, and job queue parameters",
          "done": false
        },
        {
          "text": "Default behavior unchanged \u2014 production uses real implementations when None passed",
          "done": false
        },
        {
          "text": "Test mode injects recording/in-memory fakes through the same interface",
          "done": false
        },
        {
          "text": "At least one integration test demonstrates the test wiring end-to-end",
          "done": false
        }
      ],
      "notes": "Use case: A test author needs to verify end-to-end API behavior with recording fakes. They call create_app(executor=RecordingFFmpegExecutor(), repository=InMemoryVideoRepository()) and get a fully wired FastAPI app where every dependency is a test double \u2014 no monkey-patching, no module-level globals to swap.",
      "use_case": "This feature addresses: Add dependency injection to create_app() for test wiring. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "test-foundation",
      "upvotes": 0
    },
    {
      "id": "BL-022",
      "title": "Build fixture factory with builder pattern for test data",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:56:48.722950",
      "completed_at": "2026-02-09T06:28:50.928000",
      "tags": [
        "v004",
        "testing",
        "fixtures"
      ],
      "description": "No builder-pattern fixture factory exists for creating test data. Tests currently construct project and clip objects inline with repetitive setup code. The 07-quality-architecture.md spec requires `with_clip()`, `with_text_overlay()`, `build()`, and `create_via_api()` methods. Without a fixture factory, tests are verbose, inconsistent, and fragile when data models change.",
      "acceptance_criteria": [
        {
          "text": "Builder creates test projects with configurable clips and effects via chained methods",
          "done": false
        },
        {
          "text": "build() returns domain objects directly for unit tests without HTTP",
          "done": false
        },
        {
          "text": "create_via_api() exercises the full HTTP path for black box tests",
          "done": false
        },
        {
          "text": "Pytest fixtures use the factory, replacing inline test data construction",
          "done": false
        }
      ],
      "notes": "Use case: A developer writes a test for clip reordering. Instead of 15 lines of manual dict construction, they write ProjectBuilder().with_clip(start=0, end=5).with_clip(start=5, end=10).build() and get a valid Project with two clips. When the Clip model adds a new required field next version, only the builder needs updating \u2014 not every test.",
      "use_case": "This feature addresses: Build fixture factory with builder pattern for test data. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "test-foundation",
      "upvotes": 0
    },
    {
      "id": "BL-023",
      "title": "Implement black box test scenario catalog",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:56:54.536604",
      "completed_at": "2026-02-09T06:28:52.100090",
      "tags": [
        "v004",
        "testing",
        "black-box"
      ],
      "description": "No black box integration tests exist despite the API being stable since v003. The 07-quality-architecture.md spec requires tests that exercise complete workflows through the REST API using real Rust core plus recording fakes. Without these tests, regressions in end-to-end flows (scan \u2192 project \u2192 clips) go undetected until manual testing.",
      "acceptance_criteria": [
        {
          "text": "Core workflow test covers scan \u2192 project \u2192 clips flow through REST API",
          "done": false
        },
        {
          "text": "Error handling tests cover validation errors and FFmpeg failure scenarios",
          "done": false
        },
        {
          "text": "All tests use recording test doubles and never mock the Rust core directly",
          "done": false
        },
        {
          "text": "Tests run in CI without FFmpeg installed",
          "done": false
        },
        {
          "text": "pytest markers separate black box tests from unit tests",
          "done": false
        }
      ],
      "notes": "Use case: After refactoring the scan endpoint to be async, a developer runs the black box test suite. Tests exercise the full scan \u2192 project \u2192 clips workflow through HTTP requests against a real FastAPI app with recording fakes. A regression where scan results no longer populate the video library is caught before it reaches main.",
      "use_case": "This feature addresses: Implement black box test scenario catalog. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "blackbox-contract",
      "upvotes": 0
    },
    {
      "id": "BL-024",
      "title": "Contract tests with real FFmpeg for executor fidelity",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:04.009812",
      "completed_at": "2026-02-09T06:28:53.206836",
      "tags": [
        "v004",
        "testing",
        "ffmpeg",
        "contract"
      ],
      "description": "RecordingFFmpegExecutor and FakeFFmpegExecutor exist from v001-v002, but no tests verify they produce behavior identical to RealFFmpegExecutor. This was explicitly deferred from v001 and is required by M1.9 (quality verification). Without contract tests, recording fakes may silently diverge from real FFmpeg behavior, undermining the validity of all integration tests that rely on them.",
      "acceptance_criteria": [
        {
          "text": "Parametrized tests run the same commands against Real, Recording, and Fake executors",
          "done": false
        },
        {
          "text": "At least 5 representative FFmpeg commands tested across executor implementations",
          "done": false
        },
        {
          "text": "Tests marked with @pytest.mark.requires_ffmpeg for CI environments without FFmpeg",
          "done": false
        },
        {
          "text": "Contract violations between fake and real executor fail the test suite",
          "done": false
        }
      ],
      "notes": "Use case: The RecordingFFmpegExecutor is used in all integration tests. A developer changes how FFmpeg handles concat operations in the real executor. Without contract tests, the recording fake still returns old behavior, and integration tests pass even though real FFmpeg would fail. Contract tests catch the divergence by running identical commands against both executors.",
      "use_case": "This feature addresses: Contract tests with real FFmpeg for executor fidelity. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "blackbox-contract",
      "upvotes": 0
    },
    {
      "id": "BL-025",
      "title": "Security audit of Rust path validation and input sanitization",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:10.187170",
      "completed_at": "2026-02-09T06:28:54.370009",
      "tags": [
        "v004",
        "security",
        "audit"
      ],
      "description": "M1.9 specifies a security review of Rust sanitization covering path traversal, null bytes, and shell injection vectors. The Rust core handles user-provided file paths and filter text (via `escape_filter_text()`), but no formal audit artifact documents what has been reviewed, what attack vectors are covered, and where gaps remain. Without this audit, security coverage is implicit and unverifiable.",
      "acceptance_criteria": [
        {
          "text": "Review covers path traversal, null byte injection, and shell injection vectors in Rust core",
          "done": false
        },
        {
          "text": "Audit document published in docs/ with findings and coverage assessment",
          "done": false
        },
        {
          "text": "Any identified gaps addressed with new tests or code fixes",
          "done": false
        }
      ],
      "notes": "Use case: A user provides a file path like \"../../etc/passwd\" or a text overlay containing shell metacharacters. The Rust core must reject these inputs before they reach FFmpeg. The security audit documents which attack vectors are tested, which code paths handle them, and whether any gaps exist \u2014 giving the team confidence that user input cannot escape the sandbox.",
      "use_case": "This feature addresses: Security audit of Rust path validation and input sanitization. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "security-performance",
      "upvotes": 0
    },
    {
      "id": "BL-026",
      "title": "Rust vs Python performance benchmark for core operations",
      "priority": "P3",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:15.444447",
      "completed_at": "2026-02-09T06:28:55.484143",
      "tags": [
        "v004",
        "benchmarking",
        "rust"
      ],
      "description": "M1.9 requires benchmarking Rust core operations against pure-Python equivalents to validate the performance justification for the hybrid architecture. No benchmark infrastructure exists. Without measured speedup ratios, the decision to use Rust for timeline math and filter generation lacks empirical backing.",
      "acceptance_criteria": [
        {
          "text": "Benchmark script compares Rust vs Python for at least 3 representative operations",
          "done": false
        },
        {
          "text": "Results documented with speedup ratios for each operation",
          "done": false
        },
        {
          "text": "Benchmark runnable via uv run python benchmarks/ command",
          "done": false
        }
      ],
      "notes": "Use case: A stakeholder asks whether the Rust/Python hybrid architecture is justified. The benchmark suite runs timeline calculations, filter generation, and clip validation in both pure Python and Rust, producing a comparison table showing that Rust is N\u00d7 faster for each operation \u2014 providing empirical evidence for the architecture decision.",
      "use_case": "This feature addresses: Rust vs Python performance benchmark for core operations. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "security-performance",
      "upvotes": 0
    },
    {
      "id": "BL-027",
      "title": "Async job queue for scan operations",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:21.142515",
      "completed_at": "2026-02-09T06:28:56.559249",
      "tags": [
        "v004",
        "async",
        "scan"
      ],
      "description": "The scan endpoint blocks the HTTP request until the entire directory scan completes. This was identified as tech debt in the v003 retrospective. For large media directories, scan can take significant time, leaving the client with no progress feedback. The black box test scenario catalog (M1.8) also requires async scan behavior to test job progress workflows.",
      "acceptance_criteria": [
        {
          "text": "Scan endpoint returns job ID immediately instead of blocking",
          "done": false
        },
        {
          "text": "Job status queryable via GET endpoint with progress information",
          "done": false
        },
        {
          "text": "InMemoryJobQueue supports synchronous test execution for deterministic tests",
          "done": false
        },
        {
          "text": "Existing scan tests updated to use the async pattern",
          "done": false
        }
      ],
      "notes": "Use case: A user starts a scan of a large media directory (10,000+ files). Instead of waiting 30 seconds for the HTTP response, they get a job ID back immediately and can poll for progress. The GUI shows a progress bar updating in real-time. If they navigate away and come back, the job status endpoint tells them the scan is 73% complete.",
      "use_case": "This feature addresses: Async job queue for scan operations. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "async-scan",
      "upvotes": 0
    },
    {
      "id": "BL-028",
      "title": "EXP: Frontend framework selection and Vite project setup",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:38.184470",
      "completed_at": "2026-02-09T18:43:02.397488",
      "tags": [
        "v005",
        "gui",
        "investigation"
      ],
      "description": "No frontend project exists \u2014 no `gui/` directory, package.json, or framework choice has been finalized. The 08-gui-architecture.md suggests React 18+ or Svelte 4+ with Vite and Tailwind. BL-003 covers investigating FastAPI static file serving but not the framework decision or project scaffolding. All v005 GUI milestones (M1.10\u2013M1.12) are blocked until a frontend project is in place.",
      "acceptance_criteria": [
        {
          "text": "Framework selected (React vs Svelte) with documented rationale",
          "done": false
        },
        {
          "text": "gui/ project scaffolded with Vite, Tailwind CSS, and TypeScript",
          "done": false
        },
        {
          "text": "npm run build produces gui/dist/ with a working bundle",
          "done": false
        },
        {
          "text": "FastAPI serves the built frontend at /gui/* routes",
          "done": false
        },
        {
          "text": "Dev proxy configured for Vite HMR during development",
          "done": false
        }
      ],
      "notes": "Use case: A user opens the application URL and expects to see a functioning web interface. Currently there is no frontend at all \u2014 no gui/ directory, no package.json, no framework. This item bootstraps the entire frontend project so that subsequent GUI features (shell, dashboard, library browser) have a foundation to build on.",
      "use_case": "This feature addresses: EXP: Frontend framework selection and Vite project setup. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "frontend-foundation",
      "upvotes": 0
    },
    {
      "id": "BL-029",
      "title": "Implement WebSocket endpoint for real-time events",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:43.982521",
      "completed_at": "2026-02-09T18:43:03.473592",
      "tags": [
        "v005",
        "websocket",
        "api"
      ],
      "description": "M1.10 requires a `/ws` WebSocket endpoint for real-time event broadcasting, but no WebSocket support exists in the current FastAPI app. The application shell needs live health status updates and the dashboard needs an activity feed. Without WebSocket support, the GUI must resort to polling, creating unnecessary load and delayed feedback.",
      "acceptance_criteria": [
        {
          "text": "/ws endpoint accepts WebSocket connections with proper handshake",
          "done": false
        },
        {
          "text": "Health status changes broadcast to all connected clients",
          "done": false
        },
        {
          "text": "Activity events (scan started/completed, project created) broadcast in real time",
          "done": false
        },
        {
          "text": "Connection lifecycle tested: connect, disconnect, reconnect scenarios",
          "done": false
        },
        {
          "text": "WebSocket messages include correlation IDs from existing middleware",
          "done": false
        }
      ],
      "notes": "Use case: A user triggers a directory scan from the library browser and sees a spinning indicator while the scan runs. When the scan completes, the video grid updates automatically without a page refresh. This real-time feedback requires WebSocket push from the server \u2014 without it, the user must manually refresh to see new videos.",
      "use_case": "This feature addresses: Implement WebSocket endpoint for real-time events. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "frontend-foundation",
      "upvotes": 0
    },
    {
      "id": "BL-030",
      "title": "Build application shell and navigation components",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:50.109098",
      "completed_at": "2026-02-09T18:43:04.589424",
      "tags": [
        "v005",
        "gui",
        "shell"
      ],
      "description": "M1.10 specifies an application shell with navigation tabs, status bar, and health indicator, but no frontend components exist. The shell is the frame that hosts all other GUI panels (library browser, project manager, effect workshop). Without it, individual components have no layout structure or navigation context.",
      "acceptance_criteria": [
        {
          "text": "Navigation between Dashboard, Library, and Projects tabs works with URL routing",
          "done": false
        },
        {
          "text": "Health indicator polls /health/ready and displays green/yellow/red status",
          "done": false
        },
        {
          "text": "Status bar displays WebSocket connection state",
          "done": false
        },
        {
          "text": "Progressive tabs \u2014 only shows features whose backends are available",
          "done": false
        },
        {
          "text": "Component unit tests pass in Vitest",
          "done": false
        }
      ],
      "notes": "Use case: A user navigates between the Dashboard, Library, and Projects tabs using the top navigation bar. The status bar at the bottom shows a green health indicator confirming the backend is reachable. When the server goes down, the indicator turns red and unavailable tabs are hidden, preventing the user from interacting with broken features.",
      "use_case": "This feature addresses: Build application shell and navigation components. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "gui-components",
      "upvotes": 0
    },
    {
      "id": "BL-031",
      "title": "Build dashboard panel with health cards and activity log",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:55.468176",
      "completed_at": "2026-02-09T18:43:05.793196",
      "tags": [
        "v005",
        "gui",
        "dashboard"
      ],
      "description": "M1.10 specifies a dashboard with system health cards, recent activity log, and metrics overview. No dashboard component exists. The dashboard is the landing page and primary system health visibility tool. Without it, users have no centralized view of component status (Python, Rust core, FFmpeg) or recent system activity.",
      "acceptance_criteria": [
        {
          "text": "Health cards display individual component status (Python, Rust core, FFmpeg)",
          "done": false
        },
        {
          "text": "Activity log receives and displays WebSocket events in real time",
          "done": false
        },
        {
          "text": "Metrics cards show API request count and Rust operation timing from /metrics",
          "done": false
        },
        {
          "text": "Dashboard auto-refreshes on a configurable interval",
          "done": false
        }
      ],
      "notes": "Use case: A user opens the application and lands on the dashboard. They see health cards showing Python (green), Rust core (green), and FFmpeg (yellow \u2014 not installed). The activity log shows the last scan completed 5 minutes ago with 12 new videos found. This gives the user immediate system awareness without digging into logs or API responses.",
      "use_case": "This feature addresses: Build dashboard panel with health cards and activity log. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "gui-components",
      "upvotes": 0
    },
    {
      "id": "BL-032",
      "title": "Implement thumbnail generation pipeline for video library",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:58:04.504476",
      "completed_at": "2026-02-09T18:43:07.083333",
      "tags": [
        "v005",
        "thumbnails",
        "ffmpeg"
      ],
      "description": "The library browser spec (M1.11) assumes thumbnail display for videos, but no thumbnail generation pipeline exists. Videos are scanned and stored with metadata, but no representative frame is extracted. Without thumbnails, the library browser would display a text-only list, degrading the visual browsing experience that is core to a video editing tool.",
      "acceptance_criteria": [
        {
          "text": "Thumbnail generated during video scan or on first access",
          "done": false
        },
        {
          "text": "GET /api/videos/{id}/thumbnail returns the thumbnail image",
          "done": false
        },
        {
          "text": "Configurable thumbnail size with default 320x180",
          "done": false
        },
        {
          "text": "Graceful fallback returns a placeholder for videos where extraction fails",
          "done": false
        },
        {
          "text": "RecordingFFmpegExecutor captures thumbnail generation commands for testing",
          "done": false
        }
      ],
      "notes": "Use case: A user browses the video library and sees thumbnail previews for each video instead of text-only filenames. When a new video is scanned, a representative frame is extracted and stored. For corrupt or unsupported files, a placeholder image is shown so the grid layout remains consistent.",
      "use_case": "This feature addresses: Implement thumbnail generation pipeline for video library. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "backend-services",
      "upvotes": 0
    },
    {
      "id": "BL-033",
      "title": "Build library browser with video grid, search, and scan UI",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:58:10.196219",
      "completed_at": "2026-02-09T18:43:08.087942",
      "tags": [
        "v005",
        "gui",
        "library"
      ],
      "description": "M1.11 specifies a library browser with video grid, search, sort/filter, and scan controls. No frontend components for video display exist. The library browser is the primary entry point for working with media \u2014 users need to find, browse, and select videos before creating projects. The backend API endpoints (search, list, scan) exist from v003 but have no GUI consumer.",
      "acceptance_criteria": [
        {
          "text": "Video grid displays thumbnails, filename, and duration for each video",
          "done": false
        },
        {
          "text": "Search bar calls /api/videos/search with debounced input",
          "done": false
        },
        {
          "text": "Sort by date, name, or duration updates the grid",
          "done": false
        },
        {
          "text": "Scan modal triggers directory scan and shows progress feedback",
          "done": false
        },
        {
          "text": "Virtual scrolling or pagination handles libraries with 100+ videos",
          "done": false
        }
      ],
      "notes": "Use case: A user wants to find a specific clip in a library of 200+ videos. They type a partial filename in the search bar and see results update as they type. They sort by date to find recently added clips, then click the Scan button to add videos from a new directory. The scan modal shows progress and the grid updates when new files are found.",
      "use_case": "This feature addresses: Build library browser with video grid, search, and scan UI. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "gui-components",
      "upvotes": 0
    },
    {
      "id": "BL-034",
      "title": "Fix pagination total count for list endpoints",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:58:15.599657",
      "completed_at": "2026-02-09T18:43:09.091777",
      "tags": [
        "v005",
        "api",
        "pagination"
      ],
      "description": "Paginated list endpoints return page-based results but lack a true total count. This was identified as tech debt in the v003 retrospective. The library browser needs the total count for virtual scrolling (to size the scroll container) and for displaying \"X of Y results\" feedback. Without it, the frontend cannot accurately represent the full dataset size.",
      "acceptance_criteria": [
        {
          "text": "List endpoints return a total field with the full count of matching items",
          "done": false
        },
        {
          "text": "Search endpoint returns total matching results separate from page size",
          "done": false
        },
        {
          "text": "Existing pagination tests updated to verify total count accuracy",
          "done": false
        }
      ],
      "notes": "Use case: The library browser displays \"Showing 20 of ?\" because the API returns paginated results without a total count. With the fix, it shows \"Showing 20 of 247 videos\" and the scrollbar accurately represents the full dataset size, enabling smooth virtual scrolling through large libraries.",
      "use_case": "This feature addresses: Fix pagination total count for list endpoints. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "backend-services",
      "upvotes": 0
    },
    {
      "id": "BL-035",
      "title": "Build project manager with list, creation, and details views",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:58:20.785944",
      "completed_at": "2026-02-09T18:43:10.193544",
      "tags": [
        "v005",
        "gui",
        "projects"
      ],
      "description": "M1.12 specifies a project manager with project list, creation modal, and details view showing Rust-calculated timeline positions. No frontend components for project management exist. The project API endpoints exist from v003, but users cannot create, browse, or inspect projects through the GUI. This is the last GUI milestone in Phase 1.",
      "acceptance_criteria": [
        {
          "text": "Project list displays name, creation date, and clip count",
          "done": false
        },
        {
          "text": "New Project modal validates output settings (resolution, fps, format)",
          "done": false
        },
        {
          "text": "Project details view displays clip list with Rust-calculated timeline positions",
          "done": false
        },
        {
          "text": "Delete action requires confirmation dialog before execution",
          "done": false
        },
        {
          "text": "Component unit tests pass in Vitest",
          "done": false
        }
      ],
      "notes": "Use case: A user clicks \"New Project\", enters output settings (1080p, 30fps, MP4), and creates a project. They navigate to the project list, see it alongside other projects, and click through to the details view where clips are listed with Rust-calculated timeline positions showing start/end times. They can delete old projects with a confirmation dialog to prevent accidents.",
      "use_case": "This feature addresses: Build project manager with list, creation, and details views. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "gui-components",
      "upvotes": 0
    },
    {
      "id": "BL-036",
      "title": "Set up Playwright E2E test infrastructure for GUI",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:58:25.894825",
      "completed_at": "2026-02-09T18:43:11.355663",
      "tags": [
        "v005",
        "testing",
        "e2e"
      ],
      "description": "The 08-gui-architecture.md quality requirements specify Playwright for E2E testing, but no E2E test infrastructure exists. Unit tests (Vitest) cover individual components, but there are no tests verifying that the full stack (FastAPI + built frontend) works end-to-end. Without E2E tests, regressions in the integration between frontend and backend go undetected.",
      "acceptance_criteria": [
        {
          "text": "Playwright configured with CI integration in GitHub Actions",
          "done": false
        },
        {
          "text": "At least 3 E2E tests covering navigation, scan trigger, and project creation",
          "done": false
        },
        {
          "text": "Tests run against FastAPI serving the built frontend bundle",
          "done": false
        },
        {
          "text": "Accessibility checks (WCAG AA) included in test assertions",
          "done": false
        }
      ],
      "notes": "Use case: A developer pushes a change to the library browser component. CI runs Playwright tests that verify the full stack: FastAPI serves the built frontend, the browser navigates between tabs, a scan can be triggered, and a new project can be created. If the integration between frontend and backend breaks, the E2E tests catch it before merge.",
      "use_case": "This feature addresses: Set up Playwright E2E test infrastructure for GUI. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "e2e-testing",
      "upvotes": 0
    },
    {
      "id": "BL-037",
      "title": "Implement FFmpeg filter expression engine in Rust",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-08T17:58:45.828090",
      "completed_at": "2026-02-19T06:47:59.758199",
      "tags": [
        "v006",
        "rust",
        "filters",
        "expressions"
      ],
      "description": "The current filter system (v001) handles simple key=value parameters only. FFmpeg filter expressions like `enable='between(t,3,5)'`, alpha expressions, and time-based arithmetic have no Rust representation. M2.1 requires a type-safe expression builder that prevents syntactically invalid expressions. Without this, text overlay animations (M2.2), speed control (M2.3), and all v007 effects cannot be built safely.",
      "acceptance_criteria": [
        {
          "text": "Expression types cover enable, alpha, time, and arithmetic expressions",
          "done": false
        },
        {
          "text": "Builder API prevents construction of syntactically invalid expressions at compile time",
          "done": false
        },
        {
          "text": "Expressions serialize to valid FFmpeg filter syntax strings",
          "done": false
        },
        {
          "text": "Property-based tests (proptest) generate random valid expressions and verify serialization",
          "done": false
        },
        {
          "text": "PyO3 bindings expose expression builder to Python with type stubs",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement FFmpeg filter expression engine in Rust. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v006",
      "implemented_in_theme": "filter-engine",
      "upvotes": 0
    },
    {
      "id": "BL-038",
      "title": "Implement filter graph validation for pad matching",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-08T17:58:50.346126",
      "completed_at": "2026-02-19T06:48:00.916285",
      "tags": [
        "v006",
        "rust",
        "filters",
        "validation"
      ],
      "description": "The current FilterGraph (v001) builds FFmpeg filter strings but performs no validation of input/output pad matching. Invalid graphs (unconnected pads, cycles, mismatched labels) are only caught when FFmpeg rejects the command at runtime. M2.1 requires compile-time-safe graph construction. Without validation, complex filter graphs for effects composition will produce cryptic FFmpeg errors instead of actionable messages.",
      "acceptance_criteria": [
        {
          "text": "Pad labels validated for correct matching (output label feeds matching input label)",
          "done": false
        },
        {
          "text": "Unconnected pads detected and reported with the specific pad name",
          "done": false
        },
        {
          "text": "Graph cycles detected and rejected before serialization",
          "done": false
        },
        {
          "text": "Validation error messages include actionable guidance on how to fix the graph",
          "done": false
        },
        {
          "text": "Existing FilterGraph tests updated to cover validation",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement filter graph validation for pad matching. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v006",
      "implemented_in_theme": "filter-engine",
      "upvotes": 0
    },
    {
      "id": "BL-039",
      "title": "Build filter composition system for chaining, branching, and merging",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-08T17:58:55.785960",
      "completed_at": "2026-02-19T06:48:02.035518",
      "tags": [
        "v006",
        "rust",
        "filters",
        "composition"
      ],
      "description": "No support exists for composing filter chains programmatically. The current system builds individual filters but cannot chain them sequentially, branch one stream into multiple, or merge multiple streams (e.g., overlay, amix). M2.1 requires a composition API for building complex filter graphs. Without it, every effect combination must manually construct raw filter strings, which is error-prone and unvalidatable.",
      "acceptance_criteria": [
        {
          "text": "Chain composition applies filters sequentially to a single stream",
          "done": false
        },
        {
          "text": "Branch splits one stream into multiple output streams",
          "done": false
        },
        {
          "text": "Merge combines multiple streams using overlay, amix, or concat",
          "done": false
        },
        {
          "text": "Composed graphs pass FilterGraph validation automatically",
          "done": false
        },
        {
          "text": "PyO3 bindings expose composition API to Python with type stubs",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Build filter composition system for chaining, branching, and merging. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v006",
      "implemented_in_theme": "filter-engine",
      "upvotes": 0
    },
    {
      "id": "BL-040",
      "title": "Implement drawtext filter builder for text overlays",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-08T17:59:02.289043",
      "completed_at": "2026-02-19T06:48:03.141204",
      "tags": [
        "v006",
        "rust",
        "text-overlay"
      ],
      "description": "The `escape_filter_text()` function exists in the Rust sanitize module, but no structured drawtext builder handles position, font, color, shadow, box background, or alpha animation parameters. M2.2 requires a type-safe text overlay system. Without a builder, constructing drawtext filters requires manually assembling complex parameter strings with correct escaping \u2014 a frequent source of FFmpeg errors.",
      "acceptance_criteria": [
        {
          "text": "Position options support absolute coordinates, centered, and margin-based placement",
          "done": false
        },
        {
          "text": "Styling covers font size, color, shadow offset/color, and box background",
          "done": false
        },
        {
          "text": "Alpha animation supports fade in/out with configurable duration using expression engine",
          "done": false
        },
        {
          "text": "Generated drawtext filters validated as syntactically correct FFmpeg syntax",
          "done": false
        },
        {
          "text": "Contract tests verify generated commands pass ffmpeg -filter_complex validation",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement drawtext filter builder for text overlays. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v006",
      "implemented_in_theme": "filter-builders",
      "upvotes": 0
    },
    {
      "id": "BL-041",
      "title": "Implement speed control filter builders (setpts/atempo)",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:59:12.246297",
      "completed_at": "2026-02-19T06:48:04.932995",
      "tags": [
        "v006",
        "rust",
        "speed-control"
      ],
      "description": "No Rust types exist for video speed (setpts) or audio speed (atempo) control. M2.3 requires speed adjustment from 0.25x to 4.0x. The atempo filter maxes at 2.0x and requires automatic chaining for higher speeds \u2014 a non-obvious FFmpeg detail that should be encapsulated in the builder. Without these builders, speed control must be hand-coded with raw filter strings for each speed value.",
      "acceptance_criteria": [
        {
          "text": "Video speed adjustable via setpts with factor range 0.25x\u20134.0x",
          "done": false
        },
        {
          "text": "Audio speed via atempo with automatic chaining for factors above 2.0x",
          "done": false
        },
        {
          "text": "Option to drop audio entirely instead of speed-adjusting it",
          "done": false
        },
        {
          "text": "Validation rejects out-of-range values with helpful error messages",
          "done": false
        },
        {
          "text": "Unit tests cover edge cases: 1x (no-op), boundary values, extreme speeds",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement speed control filter builders (setpts/atempo). It improves the system by resolving the described requirement.",
      "implemented_in_version": "v006",
      "implemented_in_theme": "filter-builders",
      "upvotes": 0
    },
    {
      "id": "BL-042",
      "title": "Create effect discovery API endpoint",
      "priority": "P2",
      "status": "completed",
      "size": "l",
      "added": "2026-02-08T17:59:18.403862",
      "completed_at": "2026-02-19T06:48:06.031365",
      "tags": [
        "v006",
        "api",
        "effects",
        "discovery"
      ],
      "description": "M2.2 and 05-api-specification.md specify an `/effects` discovery endpoint, but no such endpoint exists. The frontend needs a way to discover available effects with their parameter schemas and AI hints. Without a discovery endpoint, the GUI must hard-code knowledge of available effects, breaking the extensibility model and preventing the v007 Effect Workshop from dynamically generating parameter forms.",
      "acceptance_criteria": [
        {
          "text": "GET /effects returns a list of all available effects",
          "done": false
        },
        {
          "text": "Each effect includes name, description, and parameter JSON schema",
          "done": false
        },
        {
          "text": "AI hints included for each parameter to guide user input",
          "done": false
        },
        {
          "text": "Text overlay and speed control registered as discoverable effects",
          "done": false
        },
        {
          "text": "Response includes Rust-generated filter preview for default parameters",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Create effect discovery API endpoint. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v006",
      "implemented_in_theme": "effects-api",
      "upvotes": 0
    },
    {
      "id": "BL-043",
      "title": "Create API endpoint to apply text overlay effect to clips",
      "priority": "P2",
      "status": "completed",
      "size": "l",
      "added": "2026-02-08T17:59:24.988435",
      "completed_at": "2026-02-19T06:48:07.177129",
      "tags": [
        "v006",
        "api",
        "text-overlay"
      ],
      "description": "No API endpoint exists to apply effects to clips. The Rust drawtext builder will generate filter strings, but there is no REST endpoint to receive effect parameters, apply them to a specific clip, and store the configuration in the project model. M2.2 requires this bridge between the Rust effects engine and the clip/project data model. The clip model currently has no field for storing applied effects.",
      "acceptance_criteria": [
        {
          "text": "POST endpoint applies text overlay parameters to a specified clip",
          "done": false
        },
        {
          "text": "Effect configuration stored persistently in the clip/project model",
          "done": false
        },
        {
          "text": "Response includes the generated FFmpeg filter string for transparency",
          "done": false
        },
        {
          "text": "Validation errors from Rust surface as structured API error responses",
          "done": false
        },
        {
          "text": "Black box test covers the apply \u2192 verify filter string flow",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Create API endpoint to apply text overlay effect to clips. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v006",
      "implemented_in_theme": "effects-api",
      "upvotes": 0
    },
    {
      "id": "BL-044",
      "title": "Implement audio mixing filter builders (amix/volume/fade)",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-08T17:59:41.434479",
      "completed_at": "2026-02-19T22:57:02.037211",
      "tags": [
        "v007",
        "rust",
        "audio",
        "mixing"
      ],
      "description": "No Rust types exist for audio mixing, volume control, or audio fade effects. M2.4 requires amix for combining audio tracks, per-track volume control, fade in/out, and audio ducking patterns. The existing filter system handles video filters only. Without audio builders, mixing multiple audio sources (music + speech) requires manual FFmpeg filter string construction with no validation or ducking automation.",
      "acceptance_criteria": [
        {
          "text": "amix filter builder supports configurable number of input tracks",
          "done": false
        },
        {
          "text": "Per-track volume control validates range 0.0\u201310.0 using existing validate_volume",
          "done": false
        },
        {
          "text": "Audio fade in/out supports configurable duration via expression engine",
          "done": false
        },
        {
          "text": "Audio ducking pattern lowers music volume during speech segments",
          "done": false
        },
        {
          "text": "Edge case tests cover silence, clipping prevention, and format mismatches",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement audio mixing filter builders (amix/volume/fade). It improves the system by resolving the described requirement.",
      "implemented_in_version": "v007",
      "implemented_in_theme": "rust-filter-builders",
      "upvotes": 0
    },
    {
      "id": "BL-045",
      "title": "Implement transition filter builders (fade/xfade)",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:59:46.825964",
      "completed_at": "2026-02-19T22:57:03.218415",
      "tags": [
        "v007",
        "rust",
        "transitions"
      ],
      "description": "No Rust types exist for video transitions. M2.5 requires fade in, fade out, crossfade between clips, and xfade with selectable transition effects (wipeleft, slideright, etc.). Transitions are fundamental to video editing but currently have no type-safe builder. Without these, transition effects must be manually assembled as raw FFmpeg filter strings with no parameter validation.",
      "acceptance_criteria": [
        {
          "text": "Fade in/out with configurable duration and color",
          "done": false
        },
        {
          "text": "Crossfade between two clips with overlap duration parameter",
          "done": false
        },
        {
          "text": "xfade supports selectable effect types (fade, wipeleft, slideright, etc.)",
          "done": false
        },
        {
          "text": "Parameter validation rejects invalid duration or effect type with helpful messages",
          "done": false
        },
        {
          "text": "PyO3 bindings expose transition builders to Python with type stubs",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement transition filter builders (fade/xfade). It improves the system by resolving the described requirement.",
      "implemented_in_version": "v007",
      "implemented_in_theme": "rust-filter-builders",
      "upvotes": 0
    },
    {
      "id": "BL-046",
      "title": "Create transition API endpoint for clip-to-clip transitions",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:59:51.298982",
      "completed_at": "2026-02-19T22:57:04.502108",
      "tags": [
        "v007",
        "api",
        "transitions"
      ],
      "description": "M2.5 specifies an `/effects/transition` endpoint for applying transitions between adjacent clips, but no such endpoint exists. The Rust transition builders will generate filter strings, but there is no REST endpoint to receive transition parameters, validate clip adjacency, and store the transition in the project timeline. Without this, transitions cannot be applied through the API.",
      "acceptance_criteria": [
        {
          "text": "POST endpoint applies a transition between two specified clips",
          "done": false
        },
        {
          "text": "Validates that the two clips are adjacent in the project timeline",
          "done": false
        },
        {
          "text": "Response includes the generated FFmpeg filter string",
          "done": false
        },
        {
          "text": "Transition configuration stored persistently in the project model",
          "done": false
        },
        {
          "text": "Black box test covers apply transition and verify filter output flow",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Create transition API endpoint for clip-to-clip transitions. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v007",
      "implemented_in_theme": "effect-registry-api",
      "upvotes": 0
    },
    {
      "id": "BL-047",
      "title": "Build effect registry with JSON schema validation and builder protocol",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-08T17:59:58.051286",
      "completed_at": "2026-02-19T22:57:05.611359",
      "tags": [
        "v007",
        "registry",
        "effects",
        "schema"
      ],
      "description": "M2.6 specifies a central effect registry where each effect is registered with its JSON schema, Rust validation functions, and builder protocol. The v006 discovery endpoint provides basic listing, but the full registry pattern \u2014 schema validation, effect builder injection, and metrics tracking \u2014 is missing. Without a registry, each effect is independently wired, making the Effect Workshop GUI unable to dynamically generate forms or validate parameters.",
      "acceptance_criteria": [
        {
          "text": "Registry stores effect metadata, parameter JSON schemas, and builder references",
          "done": false
        },
        {
          "text": "JSON schema validation enforces parameter constraints for all registered effects",
          "done": false
        },
        {
          "text": "Effect builder protocol supports dependency injection for effect construction",
          "done": false
        },
        {
          "text": "All existing effects (text overlay, speed, audio, transitions) registered",
          "done": false
        },
        {
          "text": "effect_applications_total Prometheus counter increments by effect type on application",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Build effect registry with JSON schema validation and builder protocol. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v007",
      "implemented_in_theme": "effect-registry-api",
      "upvotes": 0
    },
    {
      "id": "BL-048",
      "title": "Build effect catalog UI component",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T18:00:07.485872",
      "completed_at": "2026-02-19T22:57:06.657699",
      "tags": [
        "v007",
        "gui",
        "effects",
        "catalog"
      ],
      "description": "M2.8 specifies an effect catalog component for browsing and selecting available effects, but no such frontend component exists. The `/effects` discovery endpoint (v006) provides the data, but there is no UI to consume it. Users need a visual catalog to discover what effects are available before they can configure and apply them. This is the entry point for the entire Effect Workshop workflow.",
      "acceptance_criteria": [
        {
          "text": "Grid/list view displays available effects fetched from /effects endpoint",
          "done": false
        },
        {
          "text": "Effect cards show name, description, and category",
          "done": false
        },
        {
          "text": "AI hints displayed as contextual tooltips on each effect",
          "done": false
        },
        {
          "text": "Search and filter by category narrows the displayed effects",
          "done": false
        },
        {
          "text": "Clicking an effect opens its parameter configuration form",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Build effect catalog UI component. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v007",
      "implemented_in_theme": "effect-workshop-gui",
      "upvotes": 0
    },
    {
      "id": "BL-049",
      "title": "Build dynamic parameter form generator from JSON schema",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-08T18:00:14.349552",
      "completed_at": "2026-02-19T22:57:07.771281",
      "tags": [
        "v007",
        "gui",
        "effects",
        "forms"
      ],
      "description": "M2.8 specifies auto-generating parameter forms from JSON schema, but no dynamic form rendering component exists. Each effect has a unique parameter schema (from the effect registry), and building static forms per effect doesn't scale. Without a schema-driven form generator, every new effect requires custom frontend code for its parameter UI, and the live filter preview feature cannot work generically.",
      "acceptance_criteria": [
        {
          "text": "Forms generated dynamically from effect JSON schema definitions",
          "done": false
        },
        {
          "text": "Supports parameter types: number (with range slider), string, enum (dropdown), boolean, color picker",
          "done": false
        },
        {
          "text": "Inline validation displays error messages from Rust validation",
          "done": false
        },
        {
          "text": "Live filter string preview updates as parameter values change",
          "done": false
        },
        {
          "text": "Default values pre-populated from the JSON schema",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Build dynamic parameter form generator from JSON schema. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v007",
      "implemented_in_theme": "effect-workshop-gui",
      "upvotes": 0
    },
    {
      "id": "BL-050",
      "title": "Implement live FFmpeg filter preview in effect parameter UI",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T18:00:19.762113",
      "completed_at": "2026-02-19T22:57:08.886165",
      "tags": [
        "v007",
        "gui",
        "preview",
        "transparency"
      ],
      "description": "M2.8 specifies showing the Rust-generated FFmpeg filter string in real time as users adjust effect parameters. This is the core transparency feature \u2014 users see exactly what commands Rust generates. No such preview component exists. Without live preview, the tool's key differentiator (transparency into FFmpeg command generation) is invisible during effect configuration.",
      "acceptance_criteria": [
        {
          "text": "Filter string panel displays the current FFmpeg filter and updates on parameter change",
          "done": false
        },
        {
          "text": "API calls to get filter preview are debounced to avoid excessive requests",
          "done": false
        },
        {
          "text": "FFmpeg filter syntax displayed with syntax highlighting",
          "done": false
        },
        {
          "text": "Copy-to-clipboard button copies the filter string for external use",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement live FFmpeg filter preview in effect parameter UI. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v007",
      "implemented_in_theme": "effect-workshop-gui",
      "upvotes": 0
    },
    {
      "id": "BL-051",
      "title": "Build effect builder workflow with clip selector and effect stack",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-08T18:00:26.538591",
      "completed_at": "2026-02-19T22:57:10.011196",
      "tags": [
        "v007",
        "gui",
        "effects",
        "builder"
      ],
      "description": "M2.9 specifies a complete effect builder workflow: select effect, configure parameters, choose target clip, view the effect stack per clip, and edit/remove applied effects. No such workflow exists. Individual components (catalog, form, preview) need to be composed into a coherent workflow. Without this, users cannot complete the full loop of discovering, configuring, applying, and managing effects on clips.",
      "acceptance_criteria": [
        {
          "text": "Apply to Clip workflow presents a clip selector from the current project",
          "done": false
        },
        {
          "text": "Effect stack visualization shows all effects applied to a selected clip in order",
          "done": false
        },
        {
          "text": "Preview thumbnail displays a static frame with the effect applied",
          "done": false
        },
        {
          "text": "Edit action re-opens parameter form with existing values for an applied effect",
          "done": false
        },
        {
          "text": "Remove action deletes an effect from a clip's effect stack with confirmation",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Build effect builder workflow with clip selector and effect stack. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v007",
      "implemented_in_theme": "effect-workshop-gui",
      "upvotes": 0
    },
    {
      "id": "BL-052",
      "title": "E2E tests for effect workshop workflow",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T18:00:32.690882",
      "completed_at": "2026-02-19T22:57:11.050541",
      "tags": [
        "v007",
        "testing",
        "e2e",
        "effects"
      ],
      "description": "The effect workshop comprises multiple GUI components (catalog, form generator, preview, builder workflow) that must work together end-to-end. No E2E tests cover this workflow. The v005 Playwright infrastructure provides the foundation, but effect-specific test scenarios are needed. Without E2E coverage, regressions in the multi-step effect application workflow go undetected.",
      "acceptance_criteria": [
        {
          "text": "E2E test browses effect catalog and selects an effect",
          "done": false
        },
        {
          "text": "E2E test configures parameters and verifies filter preview updates in real time",
          "done": false
        },
        {
          "text": "E2E test applies effect to a clip and verifies effect stack display",
          "done": false
        },
        {
          "text": "E2E test edits and removes an applied effect successfully",
          "done": false
        },
        {
          "text": "Accessibility checks (WCAG AA) pass for all form components",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: E2E tests for effect workshop workflow. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v007",
      "implemented_in_theme": "quality-validation",
      "upvotes": 0
    },
    {
      "id": "BL-053",
      "title": "Add PR vs BL routing guidance to AGENTS.md (stoat-and-ferret)",
      "priority": "P1",
      "status": "cancelled",
      "size": "l",
      "added": "2026-02-14T11:57:14.106367",
      "completed_at": null,
      "tags": [
        "agents-md",
        "product-requests",
        "documentation",
        "decision-framework"
      ],
      "description": "AGENTS.md in the stoat-and-ferret project lists both add_product_request and add_backlog_item in the tool inventory but provides no guidance on when to use which. Claude Code sessions following AGENTS.md have no routing guidance for capturing ideas vs filing structured bugs.\n\nThe exploration pr-vs-bl-guidance on auto-dev-mcp (Gap 4) identified that AGENTS.md across all managed projects has zero PR vs BL routing guidance. Since AGENTS.md is the first document Claude Code reads in every session, it is the highest-leverage location for this guidance.\n\nWithout this, Claude Code defaults to add_backlog_item for all discoveries, bypassing the lightweight product request pathway entirely.",
      "acceptance_criteria": [
        {
          "text": "AGENTS.md contains a section documenting when to create a Product Request vs a Backlog Item",
          "done": false
        },
        {
          "text": "Section includes the maturity gradient: PR for ideas/observations, BL for structured problems with acceptance criteria",
          "done": false
        },
        {
          "text": "Section includes the default rule: when in doubt, start with a Product Request",
          "done": false
        },
        {
          "text": "Section cross-references add_product_request and add_backlog_item tool_help for detailed guidance",
          "done": false
        }
      ],
      "notes": "Rejected because PR vs BL routing guidance is being embedded into the core retrospective and design scripts in auto-dev-mcp, which is the right place for it. Don't want to pollute AGENTS.md with auto-dev-specific process guidance.",
      "use_case": "During any Claude Code session on stoat-and-ferret, the agent reads AGENTS.md first. When it discovers an improvement opportunity mid-implementation, it currently has no guidance on whether to file a PR or BL. With this change, AGENTS.md tells it to default to product requests for ideas and reserve backlog items for structured problems.",
      "implemented_in_version": null,
      "implemented_in_theme": null,
      "upvotes": 0
    },
    {
      "id": "BL-054",
      "title": "Add WebFetch safety rules to AGENTS.md",
      "priority": "P1",
      "status": "cancelled",
      "size": "l",
      "added": "2026-02-15T01:19:06.391688",
      "completed_at": null,
      "tags": [
        "agents-md",
        "webfetch",
        "safety",
        "hang-prevention"
      ],
      "description": "Mirror of auto-dev-mcp BL-517. Add WebFetch safety block to AGENTS.md. Exact text:\n\n## WebFetch Safety (mandatory)\n- NEVER WebFetch a URL you generated from memory \u2014 only WebFetch URLs returned by WebSearch\n- Prefer WebSearch over WebFetch for research\n- MANDATORY: Before every WebFetch call you MUST run: curl -sL --max-time 10 -o /dev/null -w \"%{http_code}\" &lt;url&gt; and ONLY proceed with WebFetch if curl returns 2xx/3xx\n\nstoat-and-ferret v006 Task 004 was the first incident \u2014 2 hung WebFetch calls froze the session for 3 hours.",
      "acceptance_criteria": [
        {
          "text": "AGENTS.md contains a '## WebFetch Safety (mandatory)' section with all 3 rules verbatim",
          "done": false
        },
        {
          "text": "The section is placed near top-level instructions, not buried at the end",
          "done": false
        },
        {
          "text": "No other changes to AGENTS.md beyond the insertion",
          "done": false
        }
      ],
      "notes": "Superseded by auto-dev-mcp BL-536 which addresses WebFetch safety at the global level in the MCP server itself, rather than per-project AGENTS.md patches.",
      "use_case": "Same as BL-517: prevent WebFetch hangs from freezing sessions by requiring URL verification before every WebFetch call.",
      "implemented_in_version": null,
      "implemented_in_theme": null,
      "upvotes": 0
    },
    {
      "id": "BL-055",
      "title": "Fix flaky E2E test in project-creation.spec.ts (toBeHidden timeout)",
      "priority": "P0",
      "status": "completed",
      "size": "l",
      "added": "2026-02-19T16:59:19.174758",
      "completed_at": "2026-02-22T10:24:16.860368",
      "tags": [
        "bug",
        "e2e",
        "ci",
        "flaky-test"
      ],
      "description": "The E2E test at gui/e2e/project-creation.spec.ts:31 intermittently fails with a toBeHidden assertion timeout on the project creation modal. The test fails on main (GitHub Actions run 22188785818) independent of any feature branch changes. During v007 execution, this caused the dynamic-parameter-forms feature to receive a 'partial' completion status despite 12/12 acceptance criteria passing and all other quality gates green. The execution pipeline halted, requiring manual restart. Any future feature touching the E2E CI job is at risk of the same false-positive halt.",
      "acceptance_criteria": [
        {
          "text": "project-creation.spec.ts:31 toBeHidden assertion passes reliably across 10 consecutive CI runs",
          "done": false
        },
        {
          "text": "No E2E test requires retry loops to pass in CI",
          "done": false
        },
        {
          "text": "Flaky test fix does not alter the tested project creation functionality",
          "done": false
        }
      ],
      "notes": "Discovered during v007 execution. PR #88 (dynamic-parameter-forms) was retried 3 times per AGENTS.md limit without resolution. Likely cause: timing-dependent modal animation or state cleanup between tests.",
      "use_case": null,
      "implemented_in_version": "v008",
      "implemented_in_theme": "ci-stability",
      "upvotes": 0
    },
    {
      "id": "BL-056",
      "title": "Wire up structured logging at application startup",
      "priority": "P1",
      "status": "completed",
      "size": "xl",
      "added": "2026-02-21T15:28:31.127809",
      "completed_at": "2026-02-22T10:24:14.604776",
      "tags": [
        "observability",
        "logging",
        "wiring-gap"
      ],
      "description": "**Current state:** `configure_logging()` exists in `src/stoat_ferret/logging.py` and 10 modules emit structlog calls, but `configure_logging()` is never called at startup. `settings.log_level` (via `STOAT_LOG_LEVEL` env var) is defined but never consumed. As a result, all `logger.info()` calls are silently dropped (Python's `lastResort` handler only shows WARNING+), and the only functioning log output is uvicorn's hardcoded `log_level=\"info\"`.\n\n**Gap:** The logging infrastructure was built in v002/v003 but never wired together. The function, the setting, and the log call sites all exist independently with no connection between them.\n\n**Impact:** No application-level logging is visible. Correlation IDs, job lifecycle events, effect registration, websocket events, and all structured log data are lost. Debugging production issues requires code changes to enable any logging.",
      "acceptance_criteria": [
        {
          "text": "Application calls configure_logging() during startup lifespan before any request handling",
          "done": false
        },
        {
          "text": "settings.log_level value is passed to configure_logging() and controls the root logger level",
          "done": false
        },
        {
          "text": "STOAT_LOG_LEVEL=DEBUG produces visible debug output on stdout",
          "done": false
        },
        {
          "text": "All existing logger.info() calls across the 10 modules produce visible structured output at INFO level",
          "done": false
        },
        {
          "text": "uvicorn log_level uses settings.log_level instead of hardcoded 'info'",
          "done": false
        },
        {
          "text": "Existing tests continue to pass with logging active",
          "done": false
        }
      ],
      "notes": "Scope: wires up existing stdout-only logging infrastructure. File-based logging is a separate follow-on item.",
      "use_case": "During development and incident debugging, any developer or the auto-dev execution pipeline needs visible structured log output to diagnose failures without modifying code.",
      "implemented_in_version": "v008",
      "implemented_in_theme": "application-startup-wiring",
      "upvotes": 0
    },
    {
      "id": "BL-057",
      "title": "Add file-based logging with rotation to logs/ directory",
      "priority": "P2",
      "status": "completed",
      "size": "l",
      "added": "2026-02-21T15:39:39.168368",
      "completed_at": "2026-02-22T17:33:19.292514",
      "tags": [
        "observability",
        "logging"
      ],
      "description": "**Current state:** After BL-056, structured logging will be wired up but outputs to stdout only. There is no persistent log output \u2014 when the process stops, all log history is lost.\n\n**Gap:** No file-based logging exists. Debugging issues after the fact requires the developer to have been watching stdout at the time. There's no way to review historical log output.\n\n**Impact:** Post-hoc debugging is impossible without log persistence. Auto-dev execution pipeline output is lost when sessions end.",
      "acceptance_criteria": [
        {
          "text": "configure_logging() adds a RotatingFileHandler writing to logs/ directory at project root",
          "done": false
        },
        {
          "text": "Log files rotate at 10MB with a configurable backup count",
          "done": false
        },
        {
          "text": "logs/ directory is created automatically on startup if it doesn't exist",
          "done": false
        },
        {
          "text": "logs/ is added to .gitignore",
          "done": false
        },
        {
          "text": "File handler uses the same structlog formatter and log level as the stdout handler",
          "done": false
        },
        {
          "text": "Stdout logging continues to work alongside file logging",
          "done": false
        }
      ],
      "notes": "Depends on BL-056 (wire up stdout logging first). Use RotatingFileHandler with maxBytes=10MB. Log directory: {project_root}/logs/. Must add logs/ to .gitignore. Use case added during v009 design backlog analysis.",
      "use_case": null,
      "implemented_in_version": "v009",
      "implemented_in_theme": "observability-pipeline",
      "upvotes": 0
    },
    {
      "id": "BL-058",
      "title": "Wire database schema creation into application startup",
      "priority": "P0",
      "status": "completed",
      "size": "l",
      "added": "2026-02-21T17:29:21.122506",
      "completed_at": "2026-02-22T10:24:13.404833",
      "tags": [
        "wiring-gap",
        "database",
        "startup"
      ],
      "description": "**Current state:** `create_tables()` exists and Alembic migrations are configured, but neither is called during application startup. A fresh database gets no schema \u2014 the application starts but any database operation will fail.\n\n**Gap:** Database initialization was built in v002/03-database-foundation but never wired into the lifespan startup sequence. Requires manual CLI intervention to create schema.\n\n**Impact:** The application cannot function against a new database without manual steps. This contradicts the project's principle that all processes must be fully automated.",
      "acceptance_criteria": [
        {
          "text": "Database tables are created automatically during application startup lifespan if they don't exist",
          "done": false
        },
        {
          "text": "Alembic migrations run at startup or a clear automated mechanism ensures schema is current",
          "done": false
        },
        {
          "text": "A fresh database with no prior state becomes fully functional after a single application start",
          "done": false
        },
        {
          "text": "Existing tests continue to pass",
          "done": false
        }
      ],
      "notes": null,
      "use_case": null,
      "implemented_in_version": "v008",
      "implemented_in_theme": "application-startup-wiring",
      "upvotes": 0
    },
    {
      "id": "BL-059",
      "title": "Wire ObservableFFmpegExecutor into dependency injection",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-21T17:29:30.577955",
      "completed_at": "2026-02-22T17:33:20.472585",
      "tags": [
        "wiring-gap",
        "observability",
        "ffmpeg"
      ],
      "description": "**Current state:** `ObservableFFmpegExecutor` exists with full metrics and structured logging instrumentation, but is never instantiated. The application uses the base executor directly, bypassing all observability.\n\n**Gap:** Created in v002/04-ffmpeg-integration but never wired into the dependency injection chain. The metrics and logging decorators are dead code.\n\n**Impact:** No visibility into FFmpeg execution \u2014 no duration metrics, no structured logs for render operations, no correlation ID tracking for debugging failed renders.",
      "acceptance_criteria": [
        {
          "text": "ObservableFFmpegExecutor is instantiated and injected as the FFmpeg executor during startup",
          "done": false
        },
        {
          "text": "FFmpeg operations emit structlog calls with duration, command preview, and correlation ID",
          "done": false
        },
        {
          "text": "Prometheus metrics for FFmpeg execution count and duration are populated after render operations",
          "done": false
        },
        {
          "text": "Recording test double remains available for test injection",
          "done": false
        }
      ],
      "notes": null,
      "use_case": null,
      "implemented_in_version": "v009",
      "implemented_in_theme": "observability-pipeline",
      "upvotes": 0
    },
    {
      "id": "BL-060",
      "title": "Wire AuditLogger into repository dependency injection",
      "priority": "P2",
      "status": "completed",
      "size": "l",
      "added": "2026-02-21T17:29:38.024412",
      "completed_at": "2026-02-22T17:33:21.486343",
      "tags": [
        "wiring-gap",
        "observability",
        "database"
      ],
      "description": "**Current state:** `AuditLogger` class exists and repository constructors accept it as a parameter, but it's never instantiated \u2014 the parameter is always None. No audit trail is produced for any database operation.\n\n**Gap:** Created in v002/03-database-foundation but never wired into the DI chain.\n\n**Impact:** No audit trail for data mutations. Debugging \"what changed and when\" requires manual database inspection.",
      "acceptance_criteria": [
        {
          "text": "AuditLogger is instantiated and injected into repositories that accept it",
          "done": false
        },
        {
          "text": "Database mutations (create, update, delete) produce audit log entries",
          "done": false
        },
        {
          "text": "Audit entries include correlation ID, resource type, and operation type",
          "done": false
        }
      ],
      "notes": null,
      "use_case": null,
      "implemented_in_version": "v009",
      "implemented_in_theme": "observability-pipeline",
      "upvotes": 0
    },
    {
      "id": "BL-061",
      "title": "Wire or remove execute_command() Rust-Python FFmpeg bridge",
      "priority": "P2",
      "status": "completed",
      "size": "l",
      "added": "2026-02-21T17:29:48.053602",
      "completed_at": "2026-02-25T11:26:11.367189",
      "tags": [
        "wiring-gap",
        "ffmpeg",
        "rust-python"
      ],
      "description": "**Current state:** `execute_command()` was built in v002/04-ffmpeg-integration as the bridge between the Rust command builder and the Python FFmpeg executor. It has zero callers in production code.\n\n**Gap:** The function exists and is tested in isolation but is never used in any render or export workflow.\n\n**Impact:** The Rust-to-Python FFmpeg pipeline has no integration point. Either the bridge needs wiring into a real workflow, or it's dead code that should be removed to reduce maintenance burden.",
      "acceptance_criteria": [
        {
          "text": "execute_command() is called by at least one render/export code path connecting Rust command builder output to Python FFmpeg executor",
          "done": false
        },
        {
          "text": "Render workflow produces a working output file via the Rust\u2192Python bridge",
          "done": false
        },
        {
          "text": "If execute_command() is genuinely unnecessary, it is removed along with its tests",
          "done": false
        }
      ],
      "notes": null,
      "use_case": null,
      "implemented_in_version": "v012",
      "implemented_in_theme": "rust-bindings-cleanup",
      "upvotes": 0
    },
    {
      "id": "BL-062",
      "title": "Wire orphaned settings (debug, ws_heartbeat_interval) to their consumers",
      "priority": "P2",
      "status": "completed",
      "size": "l",
      "added": "2026-02-21T17:29:57.910080",
      "completed_at": "2026-02-22T10:24:15.778734",
      "tags": [
        "wiring-gap",
        "settings",
        "configuration"
      ],
      "description": "**Current state:** Two settings fields are defined with full validation and env var support but never consumed: `debug` is never passed to FastAPI or uvicorn, and `ws_heartbeat_interval` is ignored in favour of a hardcoded `DEFAULT_HEARTBEAT_INTERVAL = 30` in ws.py.\n\n**Gap:** Settings were created in v003/02-api-foundation as \"define the field\" without \"wire the field to its consumer.\"\n\n**Impact:** Operators cannot control debug mode or WebSocket heartbeat timing via configuration. The env vars exist but do nothing.",
      "acceptance_criteria": [
        {
          "text": "settings.debug is passed to FastAPI(debug=...) and/or uvicorn.run()",
          "done": false
        },
        {
          "text": "settings.ws_heartbeat_interval is read by ws.py instead of using hardcoded DEFAULT_HEARTBEAT_INTERVAL",
          "done": false
        },
        {
          "text": "No settings fields remain defined but unconsumed (excluding log_level which is covered by BL-056)",
          "done": false
        }
      ],
      "notes": null,
      "use_case": null,
      "implemented_in_version": "v008",
      "implemented_in_theme": "application-startup-wiring",
      "upvotes": 0
    },
    {
      "id": "BL-063",
      "title": "Add SPA routing fallback for GUI sub-paths",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-21T17:30:08.176968",
      "completed_at": "2026-02-22T17:33:22.642111",
      "tags": [
        "wiring-gap",
        "gui",
        "routing"
      ],
      "description": "**Current state:** FastAPI serves the GUI via `StaticFiles(html=True)`, but this does not fall back to `index.html` for unknown sub-paths. Navigating directly to `/gui/library` or refreshing on `/gui/projects` returns 404. React Router handles client-side navigation fine, but only when starting from the root.\n\n**Gap:** Standard SPA routing fallback was not implemented in v005/01-frontend-foundation. The e2e test suite explicitly works around this by navigating via tab clicks only.\n\n**Impact:** Bookmarks, page refreshes, and shared URLs to any GUI sub-page are broken.",
      "acceptance_criteria": [
        {
          "text": "Direct navigation to /gui/library, /gui/projects, and other GUI sub-paths returns the SPA index.html instead of 404",
          "done": false
        },
        {
          "text": "Page refresh on any GUI sub-path preserves the current view",
          "done": false
        },
        {
          "text": "Bookmarked and shared GUI URLs load the correct page",
          "done": false
        }
      ],
      "notes": null,
      "use_case": null,
      "implemented_in_version": "v009",
      "implemented_in_theme": "gui-runtime-fixes",
      "upvotes": 0
    },
    {
      "id": "BL-064",
      "title": "Fix projects endpoint pagination total count",
      "priority": "P2",
      "status": "completed",
      "size": "l",
      "added": "2026-02-21T17:30:16.415759",
      "completed_at": "2026-02-22T17:33:23.729959",
      "tags": [
        "wiring-gap",
        "api",
        "pagination"
      ],
      "description": "**Current state:** `GET /api/v1/projects` returns `total=len(projects)` which equals the current page size, not the true database total. A `count()` method was added to `AsyncVideoRepository` but not to `AsyncProjectRepository`.\n\n**Gap:** Pagination total count implementation was incomplete in v005/02-backend-services \u2014 only one of two repositories received the method.\n\n**Impact:** Frontend pagination metadata is incorrect when there are more projects than the page limit. Users see wrong page counts and may not discover all their projects.",
      "acceptance_criteria": [
        {
          "text": "AsyncProjectRepository has a count() method matching AsyncVideoRepository's implementation",
          "done": false
        },
        {
          "text": "GET /api/v1/projects returns correct total count reflecting all projects in the database, not just the current page",
          "done": false
        },
        {
          "text": "Frontend pagination displays correct page count when projects exceed the page limit",
          "done": false
        }
      ],
      "notes": null,
      "use_case": null,
      "implemented_in_version": "v009",
      "implemented_in_theme": "gui-runtime-fixes",
      "upvotes": 0
    },
    {
      "id": "BL-065",
      "title": "Wire WebSocket broadcast calls into API operations",
      "priority": "P2",
      "status": "completed",
      "size": "l",
      "added": "2026-02-21T17:30:27.033787",
      "completed_at": "2026-02-22T17:33:24.760994",
      "tags": [
        "wiring-gap",
        "websocket",
        "gui"
      ],
      "description": "**Current state:** The backend defines WebSocket event types (SCAN_STARTED, SCAN_COMPLETED, PROJECT_CREATED, HEALTH_STATUS) and the frontend ActivityLog listens for them, but no API operation ever calls `ConnectionManager.broadcast()`. The only messages sent are heartbeat pings.\n\n**Gap:** WebSocket infrastructure was built in v005 across 02-backend-services and 03-gui-components, but the broadcast calls were never added to the API operations that should trigger them.\n\n**Impact:** The Dashboard ActivityLog renders correctly but only ever shows heartbeat entries. Real-time feedback for scan progress, project creation, and other operations is non-functional.",
      "acceptance_criteria": [
        {
          "text": "Library scan operations trigger SCAN_STARTED and SCAN_COMPLETED WebSocket broadcasts",
          "done": false
        },
        {
          "text": "Project creation triggers PROJECT_CREATED WebSocket broadcast",
          "done": false
        },
        {
          "text": "Dashboard ActivityLog displays real application events, not just heartbeat pings",
          "done": false
        },
        {
          "text": "WebSocket event payloads include relevant context (project ID, scan path, etc.)",
          "done": false
        }
      ],
      "notes": null,
      "use_case": null,
      "implemented_in_version": "v009",
      "implemented_in_theme": "gui-runtime-fixes",
      "upvotes": 0
    },
    {
      "id": "BL-066",
      "title": "Add transition support to Effect Workshop GUI",
      "priority": "P3",
      "status": "completed",
      "size": "l",
      "added": "2026-02-21T17:30:37.704660",
      "completed_at": "2026-02-25T11:26:12.806003",
      "tags": [
        "wiring-gap",
        "gui",
        "effects",
        "transitions"
      ],
      "description": "**Current state:** `POST /projects/{id}/effects/transition` endpoint is implemented and functional, but the Effect Workshop GUI only handles per-clip effects. There is no GUI surface for the transition API.\n\n**Gap:** The transition API was built in v007/02-effect-registry-api but the Effect Workshop GUI in v007/03 was scoped to per-clip effects only.\n\n**Impact:** Transitions are only accessible via direct API calls. Users have no way to discover or apply transitions through the GUI.",
      "acceptance_criteria": [
        {
          "text": "Effect Workshop GUI includes a transition section or mode for applying transitions between clips",
          "done": false
        },
        {
          "text": "GUI calls POST /projects/{id}/effects/transition endpoint",
          "done": false
        },
        {
          "text": "User can preview and apply at least one transition type through the GUI",
          "done": false
        }
      ],
      "notes": null,
      "use_case": null,
      "implemented_in_version": "v012",
      "implemented_in_theme": "workshop-and-docs-polish",
      "upvotes": 0
    },
    {
      "id": "BL-067",
      "title": "Audit and trim unused PyO3 bindings from v001 (TimeRange ops, input sanitization)",
      "priority": "P3",
      "status": "completed",
      "size": "l",
      "added": "2026-02-21T17:30:51.088167",
      "completed_at": "2026-02-25T11:26:13.904215",
      "tags": [
        "dead-code",
        "rust-python",
        "api-surface"
      ],
      "description": "**Current state:** Several Rust functions are exposed via PyO3 but have zero production callers in Python. TimeRange list operations (find_gaps, merge_ranges, total_coverage) are design-ahead code for future timeline editing. Input sanitization functions (validate_crf, validate_speed) overlap with internal Rust validation in FFmpegCommand.build().\n\n**Gap:** Functions were exposed \"just in case\" in v001 without a consuming code path. They're tested but unused.\n\n**Impact:** Inflated public API surface increases maintenance burden and PyO3 binding complexity. Unclear to consumers which functions are intended for use vs aspirational.",
      "acceptance_criteria": [
        {
          "text": "TimeRange list operations (find_gaps, merge_ranges, total_coverage) are either used by a production code path or removed from PyO3 bindings",
          "done": false
        },
        {
          "text": "Input sanitization functions (validate_crf, validate_speed, etc.) are either called from Python production code or removed from PyO3 bindings if Rust-internal validation covers the same checks",
          "done": false
        },
        {
          "text": "Stub file reflects the final public API surface",
          "done": false
        }
      ],
      "notes": null,
      "use_case": null,
      "implemented_in_version": "v012",
      "implemented_in_theme": "rust-bindings-cleanup",
      "upvotes": 0
    },
    {
      "id": "BL-068",
      "title": "Audit and trim unused PyO3 bindings from v006 filter engine",
      "priority": "P3",
      "status": "completed",
      "size": "l",
      "added": "2026-02-21T17:31:01.421347",
      "completed_at": "2026-02-25T11:26:15.069962",
      "tags": [
        "dead-code",
        "rust-python",
        "api-surface"
      ],
      "description": "**Current state:** Three v006 filter engine features (Expression Engine, Graph Validation, Filter Composition) expose Python bindings via PyO3 that are only used in parity tests, never in production code. The Rust code uses these capabilities internally (e.g., DrawtextBuilder uses Expr for alpha fades, DuckingPattern uses composition).\n\n**Gap:** PyO3 bindings were created in v006/01-filter-engine for all three features but no Python production code consumes them. The Rust-internal usage works fine without the Python bindings.\n\n**Impact:** Six unused Python binding functions inflate the public API surface. Maintaining PyO3 wrappers for internally-consumed Rust code adds build complexity without value.",
      "acceptance_criteria": [
        {
          "text": "Expression Engine (Expr), Graph Validation (validate, validated_to_string), and Filter Composition (compose_chain, compose_branch, compose_merge) PyO3 bindings are either used by Python production code or removed from the public API",
          "done": false
        },
        {
          "text": "If bindings are retained for future use, they are documented as such in the stub file",
          "done": false
        },
        {
          "text": "Parity tests are updated to reflect any binding changes",
          "done": false
        }
      ],
      "notes": null,
      "use_case": null,
      "implemented_in_version": "v012",
      "implemented_in_theme": "rust-bindings-cleanup",
      "upvotes": 0
    },
    {
      "id": "BL-069",
      "title": "Update C4 architecture documentation for v009 changes",
      "priority": "P2",
      "status": "open",
      "size": "xl",
      "added": "2026-02-22T17:48:56.028378",
      "completed_at": null,
      "tags": [
        "architecture",
        "c4",
        "documentation"
      ],
      "description": "C4 documentation was last generated for v008. v009 introduced 6 features across 2 themes (observability-pipeline, gui-runtime-fixes) that created architecture drift in 5 areas:\n\n1. **configure_logging() now includes RotatingFileHandler**: C4 Data Access component describes logging config as \"JSON/console logging setup\" but code now includes file-based logging with rotation (log_dir parameter, 10MB rotation, 5 backups). Evidence: src/stoat_ferret/logging.py:18-21,78-80.\n\n2. **Project Repository missing count() method**: C4 Data Access lists Project Repository operations as \"add, get, list_projects, update, delete\" \u2014 missing the new count() method added for pagination. Evidence: src/stoat_ferret/db/project_repository.py:87,190,254.\n\n3. **SPA routing uses catch-all routes, not StaticFiles mount**: C4 API Gateway states \"Static File Serving: GUI static files mounted at /gui\" but StaticFiles was replaced with @app.get(\"/gui\") and @app.get(\"/gui/{path:path}\") catch-all routes serving files with SPA fallback. Evidence: src/stoat_ferret/api/app.py:206-211.\n\n4. **ObservableFFmpegExecutor and AuditLogger wired into create_app() lifespan**: These were pre-existing dead code documented in v008 C4 but are now actively wired as DI components in the lifespan \u2014 ObservableFFmpegExecutor wrapping RealFFmpegExecutor, AuditLogger with separate sync SQLite connection. Evidence: src/stoat_ferret/api/app.py:86-94.\n\n5. **WebSocket broadcasts actively wired**: v008 C4 listed SCAN_STARTED, SCAN_COMPLETED, PROJECT_CREATED event types but broadcast() calls were not wired. v009 added active broadcast calls in scan handler and project creation router. Evidence: src/stoat_ferret/api/services/scan.py:84,94 and src/stoat_ferret/api/routers/projects.py:150.\n\nThe version retrospective also notes C4 regeneration was attempted but failed for v009.",
      "acceptance_criteria": [
        {
          "text": "C4 Data Access component documents configure_logging() file rotation capability with log_dir parameter",
          "done": false
        },
        {
          "text": "C4 Data Access component lists count() in Project Repository operations",
          "done": false
        },
        {
          "text": "C4 API Gateway component describes SPA catch-all routing pattern instead of StaticFiles mount",
          "done": false
        },
        {
          "text": "C4 API Gateway component reflects ObservableFFmpegExecutor and AuditLogger as DI-managed lifespan components",
          "done": false
        },
        {
          "text": "C4 container/context docs reflect that WebSocket broadcast events are actively wired (not just defined)",
          "done": false
        }
      ],
      "notes": "Additional drift from v012:\\n\\n16. **11 PyO3 bindings removed but still listed in C4 docs**: v012 Theme 01 removed `find_gaps`, `merge_ranges`, `total_coverage`, `validate_crf`, `validate_speed` (Python-facing wrappers), `PyExpr`, `validated_to_string`, `compose_chain`, `compose_branch`, `compose_merge`, and `execute_command` + `CommandExecutionError`. These are still listed as Python-facing API in c4-container.md (lines 158-163), c4-code-rust-core.md, c4-code-stoat-ferret-core.md, c4-code-stubs-stoat-ferret-core.md, c4-code-rust-ffmpeg.md, c4-code-rust-stoat-ferret-core-ffmpeg.md, c4-code-rust-stoat-ferret-core-timeline.md, c4-code-rust-stoat-ferret-core-sanitize.md, c4-code-stoat-ferret-ffmpeg.md, and c4-component-application-services.md. Note: the Rust-internal functions still exist; only the PyO3 wrappers were removed. Evidence: PRs #113, #114, #115.\\n\\n17. **integration.py deleted but still documented**: `src/stoat_ferret/ffmpeg/integration.py` (containing `execute_command` bridge function) was deleted. Still referenced in c4-code-stoat-ferret-ffmpeg.md (lines 27, 31, 86, 90). Evidence: file no longer exists.\\n\\n18. **test_integration.py deleted but still documented**: `tests/test_integration.py` was deleted. Still referenced in c4-code-tests.md (line 34). Evidence: file no longer exists.\\n\\n19. **Component count now 25, store count now 9**: v012 Theme 02 added TransitionPanel component and transitionStore. Previous drift (notes 12-15) recorded 24 components and 8 stores; now 25 components (gui/src/components/ has 25 .tsx files) and 9 stores (gui/src/stores/ has 9 .ts files). c4-component-web-gui.md still says \\\"22 React components\\\" and \\\"7 Zustand stores\\\".\\n\\n20. **TransitionPanel and transitionStore not in C4 GUI docs**: New files gui/src/components/TransitionPanel.tsx and gui/src/stores/transitionStore.ts are not documented in c4-component-web-gui.md or c4-code-gui-components.md/c4-code-gui-stores.md. Evidence: PR #116.\\n\\n21. **ClipSelector pair-mode extension undocumented**: ClipSelector now supports optional pair-mode props (pairMode, selectedFromId, selectedToId, onSelectPair) for transition clip selection. C4 docs describe only single-select mode. Evidence: gui/src/components/ClipSelector.tsx, PR #116.",
      "use_case": "During version planning and onboarding, developers and the design agent consult C4 documentation to understand the current architecture. Stale documentation leads to incorrect assumptions about component capabilities and wiring, causing design decisions based on outdated information.",
      "implemented_in_version": null,
      "implemented_in_theme": null,
      "upvotes": 0
    },
    {
      "id": "BL-070",
      "title": "Add Browse button for scan directory path selection",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-23T10:02:50.779841",
      "completed_at": "2026-02-24T10:08:12.267589",
      "tags": [
        "gui",
        "ux",
        "library",
        "user-feedback"
      ],
      "description": "Currently the Scan Directory feature requires users to manually type or paste a directory path. There is no file/folder browser dialog to help users navigate to and select the target directory. This creates friction - users must know the exact path and type it correctly, which is error-prone and a poor UX pattern for desktop-style file selection.",
      "acceptance_criteria": [
        {
          "text": "Scan Directory UI includes a Browse button next to the path input field",
          "done": false
        },
        {
          "text": "Clicking Browse opens a folder selection dialog that allows navigating the filesystem",
          "done": false
        },
        {
          "text": "Selecting a folder in the dialog populates the path input field with the chosen path",
          "done": false
        },
        {
          "text": "Users can still manually type a path as an alternative to browsing",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "When a user wants to scan a media directory, they need to navigate to it visually rather than remembering and typing the full path, especially on systems with deep directory hierarchies.",
      "implemented_in_version": "v011",
      "implemented_in_theme": "scan-and-clip-ux",
      "upvotes": 0
    },
    {
      "id": "BL-071",
      "title": "Add .env.example file for environment configuration template",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-23T10:03:00.799713",
      "completed_at": "2026-02-24T10:08:13.415589",
      "tags": [
        "devex",
        "documentation",
        "onboarding",
        "user-feedback"
      ],
      "description": "The project has no .env.example file to guide new developers or users through environment configuration. Anyone setting up the project must reverse-engineer which environment variables are needed by reading source code. This is a common onboarding friction point - without a template, users may miss required configuration and encounter confusing startup failures.",
      "acceptance_criteria": [
        {
          "text": "A .env.example file exists in the project root with all required/optional environment variables documented",
          "done": false
        },
        {
          "text": "Each variable includes a comment explaining its purpose and acceptable values",
          "done": false
        },
        {
          "text": "The file contains sensible defaults or placeholder values (not real secrets)",
          "done": false
        },
        {
          "text": "README or setup documentation references .env.example as part of the getting-started workflow",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "When a new developer or user clones the repo, they need a clear reference for what environment variables to configure before the application will start correctly.",
      "implemented_in_version": "v011",
      "implemented_in_theme": "developer-onboarding",
      "upvotes": 0
    },
    {
      "id": "BL-072",
      "title": "Fix blocking subprocess.run() in ffprobe freezing async event loop",
      "priority": "P0",
      "status": "completed",
      "size": "l",
      "added": "2026-02-23T10:21:08.828051",
      "completed_at": "2026-02-23T23:48:13.360956",
      "tags": [
        "bug",
        "async",
        "ffmpeg",
        "scan",
        "user-feedback"
      ],
      "description": "The `ffprobe_video()` function in `src/stoat_ferret/ffmpeg/probe.py` uses synchronous `subprocess.run()` with a 30s timeout per file. This is called from the async scan handler, which blocks the entire asyncio event loop for the duration of each ffprobe call. While blocked, the server cannot handle any HTTP requests \u2014 including job status polling \u2014 making the scan appear completely frozen. This also makes `asyncio.wait_for()` timeout unreliable since the event loop has no opportunity to check it between blocking calls. This is the primary cause of the \"scan directory hangs forever\" bug.",
      "acceptance_criteria": [
        {
          "text": "ffprobe_video() uses asyncio.create_subprocess_exec() or asyncio.to_thread() instead of blocking subprocess.run()",
          "done": false
        },
        {
          "text": "HTTP status polling endpoint remains responsive during an active scan job",
          "done": false
        },
        {
          "text": "asyncio.wait_for() job timeout fires reliably at the configured threshold",
          "done": false
        },
        {
          "text": "Existing ffprobe tests pass with the async implementation",
          "done": false
        },
        {
          "text": "Scan of a directory with multiple video files completes without blocking other API requests",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "When a user scans a media directory, the server must remain responsive so progress polling, cancellation, and other API calls continue working throughout the scan.",
      "implemented_in_version": "v010",
      "implemented_in_theme": "async-pipeline-fix",
      "upvotes": 0
    },
    {
      "id": "BL-073",
      "title": "Add progress reporting to job queue and scan handler",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-23T10:21:20.060973",
      "completed_at": "2026-02-23T23:48:14.473100",
      "tags": [
        "jobs",
        "scan",
        "gui",
        "ux",
        "user-feedback"
      ],
      "description": "The job queue (`AsyncioJobQueue`), job result model (`JobResult`), and job status response (`JobStatusResponse`) have no progress field. The scan handler processes files in a loop but never reports intermediate progress. The frontend polls job status but always receives `null` for progress, so the progress bar is permanently stuck at 0%. Users have no visibility into how far along a scan is or whether it's actually working.",
      "acceptance_criteria": [
        {
          "text": "_AsyncJobEntry includes a progress field (0.0-1.0 float or integer percentage)",
          "done": false
        },
        {
          "text": "AsyncioJobQueue exposes a set_progress(job_id, value) method callable from within job handlers",
          "done": false
        },
        {
          "text": "Scan handler calls set_progress after each file, reporting scanned_count/total_files",
          "done": false
        },
        {
          "text": "GET /api/v1/jobs/{id} response includes a populated progress field during active jobs",
          "done": false
        },
        {
          "text": "Frontend ScanModal progress bar reflects actual scan progress in real time",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "During a directory scan that may take minutes, users need to see real progress to know the operation is working and estimate remaining time.",
      "implemented_in_version": "v010",
      "implemented_in_theme": "job-controls",
      "upvotes": 0
    },
    {
      "id": "BL-074",
      "title": "Implement job cancellation support for scan and job queue",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-23T10:21:31.138401",
      "completed_at": "2026-02-23T23:48:15.561851",
      "tags": [
        "jobs",
        "scan",
        "api",
        "gui",
        "user-feedback"
      ],
      "description": "The `AsyncioJobQueue` has no `cancel()` method, no cancellation flag mechanism, and no cancel API endpoint. The scan handler's file processing loop has no cancellation check point. The frontend cancel button exists in ScanModal but has nothing to call \u2014 once a scan starts, the only way to stop it is to restart the server. Users are stuck waiting for potentially long scans with no way to abort.",
      "acceptance_criteria": [
        {
          "text": "AsyncioJobQueue has a cancel(job_id) method that sets a cancellation flag on the running job",
          "done": false
        },
        {
          "text": "A cancel API endpoint exists (DELETE /api/v1/jobs/{id} or POST /api/v1/jobs/{id}/cancel) returning appropriate status",
          "done": false
        },
        {
          "text": "Scan handler checks the cancellation flag between file iterations and exits cleanly when cancelled",
          "done": false
        },
        {
          "text": "Cancelled jobs report status 'cancelled' with partial results (files scanned so far are retained)",
          "done": false
        },
        {
          "text": "Frontend ScanModal cancel button calls the cancel endpoint and updates UI to reflect cancellation",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "When a user accidentally scans the wrong directory or needs to stop a long-running scan, they need the cancel button to actually work rather than being forced to restart the application.",
      "implemented_in_version": "v010",
      "implemented_in_theme": "job-controls",
      "upvotes": 0
    },
    {
      "id": "BL-075",
      "title": "Add clip management controls (Add/Edit/Delete) to project GUI",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-23T10:21:43.862781",
      "completed_at": "2026-02-24T10:08:14.580925",
      "tags": [
        "gui",
        "clips",
        "crud",
        "wiring-gap",
        "user-feedback"
      ],
      "description": "The GUI currently displays clips in a read-only table on the ProjectDetails page but provides no controls to add, edit, or remove clips. The backend API has full CRUD support for clips (POST, PATCH, DELETE on `/api/v1/projects/{id}/clips`) \u2014 all implemented and integration-tested \u2014 but the frontend never calls the write endpoints. Users must use the API directly to manage clips, which defeats the purpose of having a GUI. This was deferred from v005 (Phase 1 delivered read-only display) but is now a significant gap in the user workflow.",
      "acceptance_criteria": [
        {
          "text": "ProjectDetails page includes an Add Clip button that opens a form to create a new clip (selecting from library videos, setting in/out points)",
          "done": false
        },
        {
          "text": "Each clip row in the project clips table has Edit and Delete action buttons",
          "done": false
        },
        {
          "text": "Edit button opens an inline or modal form pre-populated with current clip properties (in/out points, label)",
          "done": false
        },
        {
          "text": "Delete button prompts for confirmation then removes the clip via DELETE /api/v1/projects/{id}/clips/{clip_id}",
          "done": false
        },
        {
          "text": "Add/Edit forms validate input and display errors from the backend (e.g. invalid time ranges)",
          "done": false
        },
        {
          "text": "Clip list refreshes after any add/update/delete operation",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "When building a project in the GUI, users need to add video clips from their library, adjust clip boundaries, and remove clips without switching to API calls or external tools.",
      "implemented_in_version": "v011",
      "implemented_in_theme": "scan-and-clip-ux",
      "upvotes": 0
    },
    {
      "id": "BL-076",
      "title": "Create IMPACT_ASSESSMENT.md with project-specific design checks",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-23T16:28:29.243036",
      "completed_at": "2026-02-24T10:08:15.634237",
      "tags": [
        "process",
        "auto-dev",
        "impact-assessment",
        "rca"
      ],
      "description": "stoat-and-ferret has no IMPACT_ASSESSMENT.md, so the auto-dev design phase runs no project-specific checks. RCA analysis identified four recurring issue patterns that project-specific impact assessment checks would catch at design time: (1) blocking subprocess calls in async context (caused the ffprobe event-loop freeze), (2) Settings fields added without .env.example updates (9 versions without .env.example), (3) features consuming prior-version backends without verifying they work (progress bar assumed v004 progress worked \u2014 it didn't), (4) GUI features with text-only input where richer mechanisms are standard (scan directory path with no browse button).",
      "acceptance_criteria": [
        {
          "text": "IMPACT_ASSESSMENT.md exists at docs/auto-dev/IMPACT_ASSESSMENT.md",
          "done": false
        },
        {
          "text": "Contains async safety check: flag features that introduce or modify subprocess.run/call/check_output or time.sleep inside files containing async def",
          "done": false
        },
        {
          "text": "Contains settings documentation check: if a version adds or modifies Settings fields, verify .env.example is updated",
          "done": false
        },
        {
          "text": "Contains cross-version wiring assumptions check: when features depend on behavior from prior versions, list assumptions explicitly",
          "done": false
        },
        {
          "text": "Contains GUI input mechanism check: for GUI features accepting user input, verify appropriate input mechanisms are specified",
          "done": false
        },
        {
          "text": "Each check section includes what to look for, why it matters, and a concrete example from project history",
          "done": false
        }
      ],
      "notes": "IMPACT_ASSESSMENT.md is project-specific, not an auto-dev process artifact. Treat as project code \u2014 the assessment criteria are tailored to stoat-and-ferret's architecture and design constraints.",
      "use_case": "During version design, the auto-dev impact assessment step reads this file and executes project-specific checks, catching recurring issue patterns before they reach implementation.",
      "implemented_in_version": "v011",
      "implemented_in_theme": "developer-onboarding",
      "upvotes": 0
    },
    {
      "id": "BL-077",
      "title": "Add CI quality gate for blocking calls in async context",
      "priority": "P2",
      "status": "completed",
      "size": "l",
      "added": "2026-02-23T16:28:45.639783",
      "completed_at": "2026-02-23T23:48:16.751126",
      "tags": [
        "ci",
        "quality-gates",
        "async",
        "lint",
        "rca"
      ],
      "description": "No automated check exists to detect synchronous blocking calls inside async code. Ruff, mypy, and pytest all pass despite `subprocess.run()` being called from an async scan handler, which froze the entire asyncio event loop. Two additional `subprocess.run()` calls exist in `src/` (executor.py:96, health.py:96) \u2014 one will cause the same problem when render jobs use the async job queue. A grep-based CI script (~20 lines) scanning for blocking calls in files containing `async def` would catch this entire class of bug at CI time.",
      "acceptance_criteria": [
        {
          "text": "A CI script or quality gate check exists that scans Python source files for blocking calls (subprocess.run, subprocess.call, subprocess.check_output, time.sleep) inside files that also contain async def",
          "done": false
        },
        {
          "text": "The check runs as part of the existing quality gates (alongside ruff, mypy, pytest)",
          "done": false
        },
        {
          "text": "The check fails with a clear error message identifying the file, line number, and the blocking call",
          "done": false
        },
        {
          "text": "The check passes on the current codebase after BL-072 is fixed (async ffprobe)",
          "done": false
        },
        {
          "text": "False positives for legitimate sync-only files are avoided by only flagging files containing async def",
          "done": false
        }
      ],
      "notes": "Depends on BL-072 (fix blocking ffprobe) being completed first, otherwise the check would immediately fail on the known bug.",
      "use_case": null,
      "implemented_in_version": "v010",
      "implemented_in_theme": "async-pipeline-fix",
      "upvotes": 0
    },
    {
      "id": "BL-078",
      "title": "Add event-loop responsiveness integration test for scan pipeline",
      "priority": "P2",
      "status": "completed",
      "size": "l",
      "added": "2026-02-23T16:28:57.593655",
      "completed_at": "2026-02-23T23:48:17.787135",
      "tags": [
        "testing",
        "integration",
        "async",
        "scan",
        "rca"
      ],
      "description": "All current scan tests mock `ffprobe_video()`, making the blocking behavior that caused the \"scan hangs forever\" bug invisible to the test suite. No integration test verifies that the server remains responsive during a scan. An event-loop responsiveness test that uses real or simulated-slow subprocess calls (not mocks) would have caught the ffprobe blocking bug and would serve as a regression guard against future async/blocking issues in the scan pipeline.",
      "acceptance_criteria": [
        {
          "text": "An integration test exists that starts a directory scan with multiple files requiring real or simulated-slow processing",
          "done": false
        },
        {
          "text": "While the scan runs, the test verifies that GET /api/v1/jobs/{id} responds within 2 seconds",
          "done": false
        },
        {
          "text": "The test does NOT mock ffprobe_video \u2014 it must exercise real or simulated subprocess behavior to detect event-loop blocking",
          "done": false
        },
        {
          "text": "The test fails if the event loop is starved (i.e. if blocking subprocess calls prevent polling responses)",
          "done": false
        },
        {
          "text": "The test passes after BL-072 (async ffprobe) is implemented",
          "done": false
        }
      ],
      "notes": "Depends on BL-072 (fix blocking ffprobe) \u2014 this test validates the fix and prevents regression. Should be implemented alongside or after BL-072.",
      "use_case": null,
      "implemented_in_version": "v010",
      "implemented_in_theme": "async-pipeline-fix",
      "upvotes": 0
    },
    {
      "id": "BL-079",
      "title": "Fix API spec examples to show realistic progress values for running jobs",
      "priority": "P3",
      "status": "completed",
      "size": "l",
      "added": "2026-02-23T16:29:09.762859",
      "completed_at": "2026-02-25T11:26:16.364742",
      "tags": [
        "documentation",
        "api-spec",
        "rca"
      ],
      "description": "The API specification at `docs/design/05-api-specification.md` (lines 280-361) shows `\"progress\": null` in the running-state job status example. This normalized null progress as the correct behavior for running jobs, making it appear correct to implementors when the field was never actually populated. The spec examples should show realistic values for all states to set correct implementor expectations.",
      "acceptance_criteria": [
        {
          "text": "The running-state job example in docs/design/05-api-specification.md shows a realistic progress value (e.g. 0.45) instead of null",
          "done": false
        },
        {
          "text": "All job status examples across the spec show realistic field values for their respective states",
          "done": false
        }
      ],
      "notes": null,
      "use_case": null,
      "implemented_in_version": "v012",
      "implemented_in_theme": "workshop-and-docs-polish",
      "upvotes": 0
    }
  ],
  "completed_count": 74,
  "cancelled_count": 0
}
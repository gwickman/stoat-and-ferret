{
  "next_id": 17,
  "updated_at": "2026-01-28T09:26:52.286502",
  "items": [
    {
      "id": "BL-001",
      "title": "EXP-001: PyO3/maturin hybrid build workflow investigation",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-01-25T14:30:12.374239",
      "completed_at": null,
      "tags": [
        "investigation",
        "v001-prerequisite",
        "rust",
        "tooling"
      ],
      "description": "Before designing v001, investigate the PyO3/maturin hybrid build chain:\n\n- How does the dev workflow actually function? (edit Rust, rebuild, import in Python)\n- What's the compile time impact?\n- How do we generate and maintain .pyi stub files?\n- What CI configuration is needed for hybrid builds?\n- Are there gotchas with maturin develop vs maturin build?\n\nThis informs Milestone 1.1 (project setup) and 1.2-1.3 (Rust core).",
      "acceptance_criteria": [
        {
          "text": "Exploration documents hybrid Python+Rust build workflow",
          "done": false
        },
        {
          "text": "Dev experience documented (edit-compile-test cycle)",
          "done": false
        },
        {
          "text": "CI setup requirements identified",
          "done": false
        },
        {
          "text": "Type stub (.pyi) generation process documented",
          "done": false
        }
      ],
      "notes": "Exploration complete. Results in comms/outbox/exploration/rust-python-hybrid/",
      "use_case": "This feature addresses: EXP-001: PyO3/maturin hybrid build workflow investigation. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-002",
      "title": "EXP-002: Recording fake pattern for FFmpeg executor",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-01-25T14:30:20.472748",
      "completed_at": null,
      "tags": [
        "investigation",
        "v001-prerequisite",
        "testing",
        "ffmpeg"
      ],
      "description": "Investigate the recording fake pattern for FFmpeg integration testing:\n\n- How does RecordingFFmpegExecutor capture commands?\n- How do we verify captured commands against expected FFmpeg syntax?\n- What's the contract test pattern — run against real FFmpeg periodically?\n- How does this integrate with the black box testing harness?\n\nThis informs v001 (basic structure) and v004 (full testing infrastructure).",
      "acceptance_criteria": [
        {
          "text": "Concrete RecordingFFmpegExecutor implementation documented",
          "done": false
        },
        {
          "text": "Recording/playback mechanism for command verification explained",
          "done": false
        },
        {
          "text": "Contract test pattern for FFmpeg commands demonstrated",
          "done": false
        },
        {
          "text": "Integration with pytest fixtures shown",
          "done": false
        }
      ],
      "notes": "Exploration complete. Results in comms/outbox/exploration/recording-fake-pattern/",
      "use_case": "This feature addresses: EXP-002: Recording fake pattern for FFmpeg executor. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-003",
      "title": "EXP-003: FastAPI static file serving for GUI",
      "priority": "P2",
      "status": "open",
      "size": "m",
      "added": "2026-01-25T14:30:30.773235",
      "completed_at": null,
      "tags": [
        "investigation",
        "v005-prerequisite",
        "gui",
        "fastapi"
      ],
      "description": "Investigate serving the React/Svelte GUI from FastAPI:\n\n- How do we configure FastAPI to serve static files from Vite build output?\n- What's the development workflow — proxy setup for hot reload?\n- How do we handle the /gui/* route mounting?\n- What about index.html fallback for SPA routing?\n\nThis informs v005 (GUI shell).",
      "acceptance_criteria": [
        {
          "text": "FastAPI StaticFiles mount configuration documented",
          "done": false
        },
        {
          "text": "Vite build output integration explained",
          "done": false
        },
        {
          "text": "Development workflow (hot reload) documented",
          "done": false
        },
        {
          "text": "Production deployment pattern shown",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: EXP-003: FastAPI static file serving for GUI. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-004",
      "title": "Expose Clip and ValidationError types to Python",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:15:52.979456",
      "completed_at": "2026-01-28T07:46:02.471405",
      "tags": [
        "python-bindings",
        "v002",
        "rust",
        "pyo3"
      ],
      "description": "Theme 02 (timeline-math) implemented Clip and ValidationError types in Rust but noted \"PyO3 bindings not yet added\". These types need to be exposed to Python with full type stubs.",
      "acceptance_criteria": [
        {
          "text": "Clip type exposed to Python with all methods",
          "done": false
        },
        {
          "text": "ValidationError exposed with field, message, actual, expected attributes",
          "done": false
        },
        {
          "text": "Type stubs updated in stubs/stoat_ferret_core/",
          "done": false
        },
        {
          "text": "Integration tests verify round-trip behavior",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Expose Clip and ValidationError types to Python. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "01-rust-python-bindings"
    },
    {
      "id": "BL-005",
      "title": "Expose TimeRange and list operations to Python",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:15:58.874332",
      "completed_at": "2026-01-28T07:45:01.464881",
      "tags": [
        "python-bindings",
        "v002",
        "rust",
        "pyo3"
      ],
      "description": "Theme 02 (timeline-math) implemented TimeRange with set operations and list operations in Rust but noted these are \"not yet exposed to Python\". Critical for Python-side timeline manipulation.",
      "acceptance_criteria": [
        {
          "text": "TimeRange type exposed to Python with half-open interval semantics",
          "done": false
        },
        {
          "text": "Set operations (overlap, intersection, union, subtraction, contains) available",
          "done": false
        },
        {
          "text": "List operations (find_gaps, merge_ranges) available",
          "done": false
        },
        {
          "text": "Type stubs updated",
          "done": false
        },
        {
          "text": "Integration tests verify all operations",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Expose TimeRange and list operations to Python. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "01-rust-python-bindings"
    },
    {
      "id": "BL-006",
      "title": "Update AGENTS.md with PyO3 bindings guidance",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:05.360801",
      "completed_at": "2026-01-28T07:45:04.497597",
      "tags": [
        "process",
        "documentation",
        "pyo3"
      ],
      "description": "v001 retrospective identified that deferring PyO3 bindings created tech debt. AGENTS.md should instruct Claude Code to add Python bindings incrementally in the same feature that implements the Rust types, rather than deferring to a later feature.",
      "acceptance_criteria": [
        {
          "text": "AGENTS.md includes section on PyO3 bindings best practices",
          "done": false
        },
        {
          "text": "Guidance states: add Python bindings in same feature as Rust implementation",
          "done": false
        },
        {
          "text": "Guidance states: do not defer bindings to a later feature",
          "done": false
        },
        {
          "text": "Example provided showing correct incremental approach",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Update AGENTS.md with PyO3 bindings guidance. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "02-tooling-process"
    },
    {
      "id": "BL-007",
      "title": "Automate type stub generation in CI",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:11.387037",
      "completed_at": "2026-01-28T07:46:13.695335",
      "tags": [
        "tooling",
        "ci",
        "pyo3",
        "type-stubs"
      ],
      "description": "Type stubs in stubs/stoat_ferret_core/ are manually maintained. This can drift from the actual Rust API. Automate stub generation in CI to catch drift early.",
      "acceptance_criteria": [
        {
          "text": "pyo3-stub-gen or equivalent generates stubs automatically",
          "done": false
        },
        {
          "text": "CI step verifies generated stubs match committed stubs",
          "done": false
        },
        {
          "text": "CI fails if stubs are out of sync with Rust API",
          "done": false
        },
        {
          "text": "Documentation on how to regenerate stubs",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Automate type stub generation in CI. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "01-rust-python-bindings"
    },
    {
      "id": "BL-008",
      "title": "Clean up Python API naming inconsistencies",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:17.330873",
      "completed_at": "2026-01-28T07:46:17.287788",
      "tags": [
        "api",
        "cleanup",
        "pyo3"
      ],
      "description": "v001 retrospective noted some Python methods have `py_` prefixes or different names than their Rust counterparts. This creates API inconsistency. Clean up naming to be consistent across languages where possible.",
      "acceptance_criteria": [
        {
          "text": "Audit all Python methods for py_ prefixes",
          "done": false
        },
        {
          "text": "Remove unnecessary py_ prefixes where Rust and Python names can match",
          "done": false
        },
        {
          "text": "Document any intentional naming differences",
          "done": false
        },
        {
          "text": "Update type stubs to match",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Clean up Python API naming inconsistencies. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "01-rust-python-bindings"
    },
    {
      "id": "BL-009",
      "title": "Add property test guidance to feature design template",
      "priority": "P2",
      "status": "open",
      "size": "m",
      "added": "2026-01-26T17:16:23.472478",
      "completed_at": null,
      "tags": [
        "process",
        "testing",
        "proptest"
      ],
      "description": "v001 retrospective suggested writing proptest invariants before implementation as executable specifications. Add guidance to feature design templates encouraging this pattern, along with tracking expected test counts.",
      "acceptance_criteria": [
        {
          "text": "Feature design template includes property test section",
          "done": false
        },
        {
          "text": "Guidance on writing proptest invariants before implementation",
          "done": false
        },
        {
          "text": "Example showing invariant-first design approach",
          "done": false
        },
        {
          "text": "Documentation on expected test count tracking",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Add property test guidance to feature design template. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-010",
      "title": "Configure Rust code coverage with llvm-cov",
      "priority": "P3",
      "status": "open",
      "size": "m",
      "added": "2026-01-26T17:16:28.865973",
      "completed_at": null,
      "tags": [
        "testing",
        "coverage",
        "rust",
        "ci"
      ],
      "description": "v001 retrospective noted Rust code coverage is not tracked. Configure llvm-cov to measure and report Rust test coverage alongside Python coverage.",
      "acceptance_criteria": [
        {
          "text": "llvm-cov configured for Rust workspace",
          "done": false
        },
        {
          "text": "Coverage reports generated during CI",
          "done": false
        },
        {
          "text": "Coverage threshold enforced (e.g., 80%)",
          "done": false
        },
        {
          "text": "Coverage visible in CI artifacts or dashboard",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Configure Rust code coverage with llvm-cov. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-011",
      "title": "Consolidate Python/Rust build backends",
      "priority": "P3",
      "status": "open",
      "size": "m",
      "added": "2026-01-26T17:16:34.152027",
      "completed_at": null,
      "tags": [
        "tooling",
        "build",
        "complexity"
      ],
      "description": "v001 uses hatchling for Python package management and maturin for Rust/PyO3 builds. This dual-backend approach adds complexity. Evaluate whether the build system can be simplified.",
      "acceptance_criteria": [
        {
          "text": "Evaluate if hatchling + maturin can be unified",
          "done": false
        },
        {
          "text": "Document build system architecture and rationale",
          "done": false
        },
        {
          "text": "Simplify if possible without breaking functionality",
          "done": false
        },
        {
          "text": "Update developer documentation",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Consolidate Python/Rust build backends. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-012",
      "title": "Fix coverage reporting gaps for ImportError fallback",
      "priority": "P3",
      "status": "open",
      "size": "m",
      "added": "2026-01-26T17:16:39.614208",
      "completed_at": null,
      "tags": [
        "testing",
        "coverage",
        "cleanup"
      ],
      "description": "v001 retrospective noted ImportError fallback code is excluded from coverage. Review all coverage exclusions and ensure they are intentional and documented.",
      "acceptance_criteria": [
        {
          "text": "Identify all coverage exclusions in Python code",
          "done": false
        },
        {
          "text": "Remove or justify each exclusion",
          "done": false
        },
        {
          "text": "ImportError fallback properly tested or documented as intentional exclusion",
          "done": false
        },
        {
          "text": "Coverage threshold maintained",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Fix coverage reporting gaps for ImportError fallback. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-013",
      "title": "Add async repository implementation for FastAPI (aiosqlite)",
      "priority": "P2",
      "status": "open",
      "size": "m",
      "added": "2026-01-28T09:26:37.042060",
      "completed_at": null,
      "tags": [
        "database",
        "async",
        "v003",
        "tech-debt"
      ],
      "description": "v002 retrospective identified that synchronous SQLite will need to be replaced with aiosqlite when FastAPI is introduced in v003. The repository pattern is already in place, so this is a straightforward implementation swap.",
      "acceptance_criteria": [
        {
          "text": "AsyncVideoRepository protocol defined",
          "done": false
        },
        {
          "text": "aiosqlite implementation created",
          "done": false
        },
        {
          "text": "Existing sync repository kept for CLI/scripts",
          "done": false
        },
        {
          "text": "Integration tests verify async behavior",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Add async repository implementation for FastAPI (aiosqlite). It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-014",
      "title": "Add Docker-based local testing option",
      "priority": "P2",
      "status": "open",
      "size": "s",
      "added": "2026-01-28T09:26:42.609453",
      "completed_at": null,
      "tags": [
        "tooling",
        "docker",
        "process",
        "developer-experience"
      ],
      "description": "v002 retrospective identified that Windows Application Control policies can block local Python testing. A Docker-based option would bypass these restrictions and provide consistent dev environments.",
      "acceptance_criteria": [
        {
          "text": "docker-compose.yml with Python + Rust build environment",
          "done": false
        },
        {
          "text": "README documents Docker-based testing workflow",
          "done": false
        },
        {
          "text": "Tests can run inside container bypassing host restrictions",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Add Docker-based local testing option. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-015",
      "title": "Add migration verification to CI (upgrade/downgrade/upgrade)",
      "priority": "P2",
      "status": "open",
      "size": "s",
      "added": "2026-01-28T09:26:47.388756",
      "completed_at": null,
      "tags": [
        "ci",
        "database",
        "migrations",
        "quality"
      ],
      "description": "v002 retrospective suggested adding migration verification to CI to ensure all migrations are fully reversible. Run upgrade/downgrade/upgrade cycle to catch issues early.",
      "acceptance_criteria": [
        {
          "text": "CI runs: alembic upgrade head && alembic downgrade base && alembic upgrade head",
          "done": false
        },
        {
          "text": "CI fails if any migration step fails",
          "done": false
        },
        {
          "text": "Documentation updated with migration testing requirements",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Add migration verification to CI (upgrade/downgrade/upgrade). It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-016",
      "title": "Unify InMemory vs FTS5 search behavior",
      "priority": "P3",
      "status": "open",
      "size": "s",
      "added": "2026-01-28T09:26:52.286493",
      "completed_at": null,
      "tags": [
        "database",
        "cleanup",
        "testing",
        "consistency"
      ],
      "description": "v002 retrospective noted that InMemoryVideoRepository uses substring match while SQLiteVideoRepository uses FTS5 full-text search. Consider unifying search behavior for consistent testing.",
      "acceptance_criteria": [
        {
          "text": "InMemoryVideoRepository uses same search semantics as SQLite FTS5",
          "done": false
        },
        {
          "text": "Tests verify consistent behavior across implementations",
          "done": false
        },
        {
          "text": "Documentation explains search behavior",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Unify InMemory vs FTS5 search behavior. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    }
  ],
  "completed_count": 6,
  "cancelled_count": 0
}
{
  "next_id": 53,
  "updated_at": "2026-02-09T18:49:57.217438",
  "items": [
    {
      "id": "BL-001",
      "title": "EXP-001: PyO3/maturin hybrid build workflow investigation",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-01-25T14:30:12.374239",
      "completed_at": null,
      "tags": [
        "investigation",
        "v001-prerequisite",
        "rust",
        "tooling"
      ],
      "description": "Before designing v001, investigate the PyO3/maturin hybrid build chain:\n\n- How does the dev workflow actually function? (edit Rust, rebuild, import in Python)\n- What's the compile time impact?\n- How do we generate and maintain .pyi stub files?\n- What CI configuration is needed for hybrid builds?\n- Are there gotchas with maturin develop vs maturin build?\n\nThis informs Milestone 1.1 (project setup) and 1.2-1.3 (Rust core).",
      "acceptance_criteria": [
        {
          "text": "Exploration documents hybrid Python+Rust build workflow",
          "done": false
        },
        {
          "text": "Dev experience documented (edit-compile-test cycle)",
          "done": false
        },
        {
          "text": "CI setup requirements identified",
          "done": false
        },
        {
          "text": "Type stub (.pyi) generation process documented",
          "done": false
        }
      ],
      "notes": "Exploration complete. Results in comms/outbox/exploration/rust-python-hybrid/",
      "use_case": "This feature addresses: EXP-001: PyO3/maturin hybrid build workflow investigation. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-002",
      "title": "EXP-002: Recording fake pattern for FFmpeg executor",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-01-25T14:30:20.472748",
      "completed_at": null,
      "tags": [
        "investigation",
        "v001-prerequisite",
        "testing",
        "ffmpeg"
      ],
      "description": "Investigate the recording fake pattern for FFmpeg integration testing:\n\n- How does RecordingFFmpegExecutor capture commands?\n- How do we verify captured commands against expected FFmpeg syntax?\n- What's the contract test pattern — run against real FFmpeg periodically?\n- How does this integrate with the black box testing harness?\n\nThis informs v001 (basic structure) and v004 (full testing infrastructure).",
      "acceptance_criteria": [
        {
          "text": "Concrete RecordingFFmpegExecutor implementation documented",
          "done": false
        },
        {
          "text": "Recording/playback mechanism for command verification explained",
          "done": false
        },
        {
          "text": "Contract test pattern for FFmpeg commands demonstrated",
          "done": false
        },
        {
          "text": "Integration with pytest fixtures shown",
          "done": false
        }
      ],
      "notes": "Exploration complete. Results in comms/outbox/exploration/recording-fake-pattern/",
      "use_case": "This feature addresses: EXP-002: Recording fake pattern for FFmpeg executor. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-003",
      "title": "EXP-003: FastAPI static file serving for GUI",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-25T14:30:30.773235",
      "completed_at": "2026-02-09T18:43:01.140225",
      "tags": [
        "investigation",
        "v005-prerequisite",
        "gui",
        "fastapi"
      ],
      "description": "Investigate serving the React/Svelte GUI from FastAPI:\n\n- How do we configure FastAPI to serve static files from Vite build output?\n- What's the development workflow — proxy setup for hot reload?\n- How do we handle the /gui/* route mounting?\n- What about index.html fallback for SPA routing?\n\nThis informs v005 (GUI shell).",
      "acceptance_criteria": [
        {
          "text": "FastAPI StaticFiles mount configuration documented",
          "done": false
        },
        {
          "text": "Vite build output integration explained",
          "done": false
        },
        {
          "text": "Development workflow (hot reload) documented",
          "done": false
        },
        {
          "text": "Production deployment pattern shown",
          "done": false
        }
      ],
      "notes": "Use case: A developer sets up the v005 GUI integration and needs to know how FastAPI will serve the Vite-built frontend bundle, how SPA client-side routing will work with server-side fallback, and what the dev workflow looks like with hot module replacement proxied through FastAPI.",
      "use_case": "This feature addresses: EXP-003: FastAPI static file serving for GUI. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "frontend-foundation"
    },
    {
      "id": "BL-004",
      "title": "Expose Clip and ValidationError types to Python",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:15:52.979456",
      "completed_at": "2026-01-28T07:46:02.471405",
      "tags": [
        "python-bindings",
        "v002",
        "rust",
        "pyo3"
      ],
      "description": "Theme 02 (timeline-math) implemented Clip and ValidationError types in Rust but noted \"PyO3 bindings not yet added\". These types need to be exposed to Python with full type stubs.",
      "acceptance_criteria": [
        {
          "text": "Clip type exposed to Python with all methods",
          "done": false
        },
        {
          "text": "ValidationError exposed with field, message, actual, expected attributes",
          "done": false
        },
        {
          "text": "Type stubs updated in stubs/stoat_ferret_core/",
          "done": false
        },
        {
          "text": "Integration tests verify round-trip behavior",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Expose Clip and ValidationError types to Python. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "01-rust-python-bindings"
    },
    {
      "id": "BL-005",
      "title": "Expose TimeRange and list operations to Python",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:15:58.874332",
      "completed_at": "2026-01-28T07:45:01.464881",
      "tags": [
        "python-bindings",
        "v002",
        "rust",
        "pyo3"
      ],
      "description": "Theme 02 (timeline-math) implemented TimeRange with set operations and list operations in Rust but noted these are \"not yet exposed to Python\". Critical for Python-side timeline manipulation.",
      "acceptance_criteria": [
        {
          "text": "TimeRange type exposed to Python with half-open interval semantics",
          "done": false
        },
        {
          "text": "Set operations (overlap, intersection, union, subtraction, contains) available",
          "done": false
        },
        {
          "text": "List operations (find_gaps, merge_ranges) available",
          "done": false
        },
        {
          "text": "Type stubs updated",
          "done": false
        },
        {
          "text": "Integration tests verify all operations",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Expose TimeRange and list operations to Python. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "01-rust-python-bindings"
    },
    {
      "id": "BL-006",
      "title": "Update AGENTS.md with PyO3 bindings guidance",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:05.360801",
      "completed_at": "2026-01-28T07:45:04.497597",
      "tags": [
        "process",
        "documentation",
        "pyo3"
      ],
      "description": "v001 retrospective identified that deferring PyO3 bindings created tech debt. AGENTS.md should instruct Claude Code to add Python bindings incrementally in the same feature that implements the Rust types, rather than deferring to a later feature.",
      "acceptance_criteria": [
        {
          "text": "AGENTS.md includes section on PyO3 bindings best practices",
          "done": false
        },
        {
          "text": "Guidance states: add Python bindings in same feature as Rust implementation",
          "done": false
        },
        {
          "text": "Guidance states: do not defer bindings to a later feature",
          "done": false
        },
        {
          "text": "Example provided showing correct incremental approach",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Update AGENTS.md with PyO3 bindings guidance. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "02-tooling-process"
    },
    {
      "id": "BL-007",
      "title": "Automate type stub generation in CI",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:11.387037",
      "completed_at": "2026-01-28T07:46:13.695335",
      "tags": [
        "tooling",
        "ci",
        "pyo3",
        "type-stubs"
      ],
      "description": "Type stubs in stubs/stoat_ferret_core/ are manually maintained. This can drift from the actual Rust API. Automate stub generation in CI to catch drift early.",
      "acceptance_criteria": [
        {
          "text": "pyo3-stub-gen or equivalent generates stubs automatically",
          "done": false
        },
        {
          "text": "CI step verifies generated stubs match committed stubs",
          "done": false
        },
        {
          "text": "CI fails if stubs are out of sync with Rust API",
          "done": false
        },
        {
          "text": "Documentation on how to regenerate stubs",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Automate type stub generation in CI. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "01-rust-python-bindings"
    },
    {
      "id": "BL-008",
      "title": "Clean up Python API naming inconsistencies",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:17.330873",
      "completed_at": "2026-01-28T07:46:17.287788",
      "tags": [
        "api",
        "cleanup",
        "pyo3"
      ],
      "description": "v001 retrospective noted some Python methods have `py_` prefixes or different names than their Rust counterparts. This creates API inconsistency. Clean up naming to be consistent across languages where possible.",
      "acceptance_criteria": [
        {
          "text": "Audit all Python methods for py_ prefixes",
          "done": false
        },
        {
          "text": "Remove unnecessary py_ prefixes where Rust and Python names can match",
          "done": false
        },
        {
          "text": "Document any intentional naming differences",
          "done": false
        },
        {
          "text": "Update type stubs to match",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Clean up Python API naming inconsistencies. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v002",
      "implemented_in_theme": "01-rust-python-bindings"
    },
    {
      "id": "BL-009",
      "title": "Add property test guidance to feature design template",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:23.472478",
      "completed_at": "2026-02-09T06:28:42.861436",
      "tags": [
        "process",
        "testing",
        "proptest",
        "v004"
      ],
      "description": "v001 retrospective suggested writing proptest invariants before implementation as executable specifications. Add guidance to feature design templates encouraging this pattern, along with tracking expected test counts.",
      "acceptance_criteria": [
        {
          "text": "Feature design template includes property test section",
          "done": false
        },
        {
          "text": "Guidance on writing proptest invariants before implementation",
          "done": false
        },
        {
          "text": "Example showing invariant-first design approach",
          "done": false
        },
        {
          "text": "Documentation on expected test count tracking",
          "done": false
        }
      ],
      "notes": "Use case: A developer designing a new Rust type (e.g., AudioMixer) opens the feature design template and sees a property test section. Following the guidance, they write proptest invariants first — \"mixing two silent tracks produces silence\", \"output duration equals longest input\" — then implement the type to satisfy them. The invariants serve as executable specifications that catch edge cases unit tests would miss.",
      "use_case": "This feature addresses: Add property test guidance to feature design template. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "devex-coverage"
    },
    {
      "id": "BL-010",
      "title": "Configure Rust code coverage with llvm-cov",
      "priority": "P3",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:28.865973",
      "completed_at": "2026-02-09T06:28:43.978905",
      "tags": [
        "testing",
        "coverage",
        "rust",
        "ci",
        "v004"
      ],
      "description": "v001 retrospective noted Rust code coverage is not tracked. Configure llvm-cov to measure and report Rust test coverage alongside Python coverage.",
      "acceptance_criteria": [
        {
          "text": "llvm-cov configured for Rust workspace",
          "done": false
        },
        {
          "text": "Coverage reports generated during CI",
          "done": false
        },
        {
          "text": "Coverage threshold enforced (e.g., 80%)",
          "done": false
        },
        {
          "text": "Coverage visible in CI artifacts or dashboard",
          "done": false
        }
      ],
      "notes": "Use case: After merging a PR that adds new Rust code, the CI pipeline runs llvm-cov and reports that Rust coverage dropped from 92% to 85%. The developer sees the uncovered lines in the CI artifact, adds tests for the missing paths, and pushes a fix — maintaining the 90% threshold before the PR can merge.",
      "use_case": "This feature addresses: Configure Rust code coverage with llvm-cov. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "devex-coverage"
    },
    {
      "id": "BL-011",
      "title": "Consolidate Python/Rust build backends",
      "priority": "P3",
      "status": "open",
      "size": "m",
      "added": "2026-01-26T17:16:34.152027",
      "completed_at": null,
      "tags": [
        "tooling",
        "build",
        "complexity"
      ],
      "description": "v001 uses hatchling for Python package management and maturin for Rust/PyO3 builds. This dual-backend approach adds complexity. Evaluate whether the build system can be simplified.",
      "acceptance_criteria": [
        {
          "text": "Evaluate if hatchling + maturin can be unified",
          "done": false
        },
        {
          "text": "Document build system architecture and rationale",
          "done": false
        },
        {
          "text": "Simplify if possible without breaking functionality",
          "done": false
        },
        {
          "text": "Update developer documentation",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Consolidate Python/Rust build backends. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-012",
      "title": "Fix coverage reporting gaps for ImportError fallback",
      "priority": "P3",
      "status": "completed",
      "size": "m",
      "added": "2026-01-26T17:16:39.614208",
      "completed_at": "2026-02-09T06:28:45.186999",
      "tags": [
        "testing",
        "coverage",
        "cleanup",
        "v004"
      ],
      "description": "v001 retrospective noted ImportError fallback code is excluded from coverage. Review all coverage exclusions and ensure they are intentional and documented.",
      "acceptance_criteria": [
        {
          "text": "Identify all coverage exclusions in Python code",
          "done": false
        },
        {
          "text": "Remove or justify each exclusion",
          "done": false
        },
        {
          "text": "ImportError fallback properly tested or documented as intentional exclusion",
          "done": false
        },
        {
          "text": "Coverage threshold maintained",
          "done": false
        }
      ],
      "notes": "Use case: A developer notices the coverage report shows 93% but suspects some lines are excluded via pragmas. They audit all # pragma: no cover comments and find the ImportError fallback for the Rust extension is excluded but could be tested by running without the compiled module. After removing unjustified exclusions and adding targeted tests, the coverage number reflects actual test quality.",
      "use_case": "This feature addresses: Fix coverage reporting gaps for ImportError fallback. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "devex-coverage"
    },
    {
      "id": "BL-013",
      "title": "Add async repository implementation for FastAPI (aiosqlite)",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-28T09:26:37.042060",
      "completed_at": "2026-01-28T22:37:18.032534Z",
      "tags": [
        "database",
        "async",
        "v003",
        "tech-debt"
      ],
      "description": "v002 retrospective identified that synchronous SQLite will need to be replaced with aiosqlite when FastAPI is introduced in v003. The repository pattern is already in place, so this is a straightforward implementation swap.",
      "acceptance_criteria": [
        {
          "text": "AsyncVideoRepository protocol defined",
          "done": true
        },
        {
          "text": "aiosqlite implementation created",
          "done": true
        },
        {
          "text": "Existing sync repository kept for CLI/scripts",
          "done": true
        },
        {
          "text": "Integration tests verify async behavior",
          "done": true
        }
      ],
      "notes": "Completed in v003/01-process-improvements",
      "use_case": "This feature addresses: Add async repository implementation for FastAPI (aiosqlite). It improves the system by resolving the described requirement.",
      "implemented_in_version": "v003",
      "implemented_in_theme": "01-process-improvements"
    },
    {
      "id": "BL-014",
      "title": "Add Docker-based local testing option",
      "priority": "P2",
      "status": "completed",
      "size": "s",
      "added": "2026-01-28T09:26:42.609453",
      "completed_at": "2026-02-09T06:28:46.257733",
      "tags": [
        "tooling",
        "docker",
        "process",
        "developer-experience",
        "v004"
      ],
      "description": "v002 retrospective identified that Windows Application Control policies can block local Python testing. A Docker-based option would bypass these restrictions and provide consistent dev environments.",
      "acceptance_criteria": [
        {
          "text": "docker-compose.yml with Python + Rust build environment",
          "done": false
        },
        {
          "text": "README documents Docker-based testing workflow",
          "done": false
        },
        {
          "text": "Tests can run inside container bypassing host restrictions",
          "done": false
        }
      ],
      "notes": "Use case: A contributor on Windows with Application Control policies enabled cannot run pytest locally because the policy blocks Python execution. They run docker-compose up test and the full test suite executes inside a Linux container, bypassing host restrictions and providing the same environment as CI.",
      "use_case": "This feature addresses: Add Docker-based local testing option. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "devex-coverage"
    },
    {
      "id": "BL-015",
      "title": "Add migration verification to CI (upgrade/downgrade/upgrade)",
      "priority": "P2",
      "status": "completed",
      "size": "s",
      "added": "2026-01-28T09:26:47.388756",
      "completed_at": "2026-01-28T22:37:18.032534Z",
      "tags": [
        "ci",
        "database",
        "migrations",
        "quality"
      ],
      "description": "v002 retrospective suggested adding migration verification to CI to ensure all migrations are fully reversible. Run upgrade/downgrade/upgrade cycle to catch issues early.",
      "acceptance_criteria": [
        {
          "text": "CI runs: alembic upgrade head && alembic downgrade base && alembic upgrade head",
          "done": true
        },
        {
          "text": "CI fails if any migration step fails",
          "done": true
        },
        {
          "text": "Documentation updated with migration testing requirements",
          "done": true
        }
      ],
      "notes": "Completed in v003/01-process-improvements",
      "use_case": "This feature addresses: Add migration verification to CI (upgrade/downgrade/upgrade). It improves the system by resolving the described requirement.",
      "implemented_in_version": "v003",
      "implemented_in_theme": "01-process-improvements"
    },
    {
      "id": "BL-016",
      "title": "Unify InMemory vs FTS5 search behavior",
      "priority": "P3",
      "status": "completed",
      "size": "s",
      "added": "2026-01-28T09:26:52.286493",
      "completed_at": "2026-02-09T06:28:47.480503",
      "tags": [
        "database",
        "cleanup",
        "testing",
        "consistency",
        "v004"
      ],
      "description": "v002 retrospective noted that InMemoryVideoRepository uses substring match while SQLiteVideoRepository uses FTS5 full-text search. Consider unifying search behavior for consistent testing.",
      "acceptance_criteria": [
        {
          "text": "InMemoryVideoRepository uses same search semantics as SQLite FTS5",
          "done": false
        },
        {
          "text": "Tests verify consistent behavior across implementations",
          "done": false
        },
        {
          "text": "Documentation explains search behavior",
          "done": false
        }
      ],
      "notes": "Use case: A test uses InMemoryVideoRepository and searches for \"sunset beach\". It finds the video because substring match hits. The same test against SQLite with FTS5 would not find it because FTS5 tokenizes differently. This inconsistency means tests pass with the in-memory double but fail in production. Unifying search semantics ensures test results predict production behavior.",
      "use_case": "This feature addresses: Unify InMemory vs FTS5 search behavior. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "blackbox-contract"
    },
    {
      "id": "BL-017",
      "title": "Optimize CI to skip heavy steps for docs-only commits",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-01-28T09:50:25.704437",
      "completed_at": "2026-01-28T22:37:18.032534Z",
      "tags": [
        "ci",
        "optimization",
        "developer-experience"
      ],
      "description": "The CI workflow runs full build and test suite even for documentation-only or housekeeping commits (e.g., version closure, changelog updates, exploration archiving). This wastes CI minutes and slows down simple administrative tasks. Implement path-based filtering or commit message detection to skip heavy steps when only docs/config files change.",
      "acceptance_criteria": [
        {
          "text": "CI workflow detects docs-only or housekeeping commits (e.g., chore:, docs: prefixes)",
          "done": true
        },
        {
          "text": "Docs-only commits skip Rust build, Python tests, and other heavy steps",
          "done": true
        },
        {
          "text": "Path filters implemented for src/, rust/, tests/ vs docs/, comms/",
          "done": true
        },
        {
          "text": "Full CI still runs on code changes and PR merges to main",
          "done": true
        }
      ],
      "notes": "Completed in v003/01-process-improvements",
      "use_case": "This feature addresses: Optimize CI to skip heavy steps for docs-only commits. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v003",
      "implemented_in_theme": "01-process-improvements"
    },
    {
      "id": "BL-018",
      "title": "Create C4 architecture documentation",
      "priority": "P2",
      "status": "open",
      "size": "s",
      "added": "2026-02-01T18:17:14.220413",
      "completed_at": null,
      "tags": [
        "documentation",
        "architecture",
        "c4"
      ],
      "description": "No C4 architecture documentation currently exists for the project. Establish documentation at appropriate levels (Context, Container, Component, Code) to document the system architecture.",
      "acceptance_criteria": [],
      "notes": "v004 retrospective architecture check (2026-02-09): The primary architecture doc (docs/design/02-architecture.md) was updated during v004 Theme 03 Feature 3 to reflect async scan, job queue, and updated data flows. No additional drift detected in the design docs. However, the v004 version retrospective explicitly notes that C4 documentation was skipped. v004 added: (1) AsyncioJobQueue with handler registration and background worker, (2) GET /api/v1/jobs/{job_id} status endpoint, (3) ALLOWED_SCAN_ROOTS security configuration with validate_scan_path(), (4) InMemory test doubles and create_app() DI pattern, (5) Docker multi-stage build infrastructure, (6) Rust coverage CI enforcement. These components should be captured when C4 documentation is created.\n\nv005 retrospective architecture check (2026-02-09): The design doc (docs/design/02-architecture.md) already includes /ws and /gui endpoint groups and high-level WebSocket/frontend descriptions added during v004. No C4 documentation exists (docs/C4-Documentation/ not found). v005 added significant frontend architecture not yet documented at the component level: (1) React/TypeScript/Vite frontend with Tailwind CSS v4, (2) ConnectionManager for WebSocket with lazy dead-connection cleanup, (3) ThumbnailService with GET /api/v1/videos/{id}/thumbnail endpoint, (4) AsyncVideoRepository.count() protocol method, (5) GUI components: Shell layout, Dashboard panel, Library Browser, Project Manager, (6) Zustand state management with 3 stores (activityStore, libraryStore, projectStore), (7) Playwright E2E testing infrastructure with CI job, (8) New settings: thumbnail_dir, gui_static_path, ws_heartbeat_interval. The design doc captures the high-level architecture correctly but lacks frontend component-level detail. C4 documentation would address this gap comprehensively.",
      "use_case": "This feature addresses: Create C4 architecture documentation. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-019",
      "title": "Add Windows bash /dev/null guidance to AGENTS.md and nul to .gitignore",
      "priority": "P1",
      "status": "open",
      "size": "m",
      "added": "2026-02-06T20:37:40.867158",
      "completed_at": null,
      "tags": [
        "windows",
        "agents-md",
        "gitignore"
      ],
      "description": "Add Windows bash null redirect guidance to AGENTS.md and add `nul` to .gitignore. In bash contexts on Windows: Always use `/dev/null` for output redirection (Git Bash correctly translates this to the Windows null device). Never use bare `nul` which gets interpreted as a literal filename in MSYS/Git Bash environments. Correct: `command > /dev/null 2>&1`. Wrong: `command > nul 2>&1`.",
      "acceptance_criteria": [],
      "notes": null,
      "use_case": "This feature addresses: Add Windows bash /dev/null guidance to AGENTS.md and nul to .gitignore. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-020",
      "title": "Implement InMemory test doubles for Projects and Jobs",
      "priority": "P1",
      "status": "completed",
      "size": "l",
      "added": "2026-02-08T17:56:36.056975",
      "completed_at": "2026-02-09T06:28:48.704164",
      "tags": [
        "v004",
        "testing",
        "test-doubles"
      ],
      "description": "The RecordingFFmpegExecutor test double exists from v002, but InMemoryProjectStorage and InMemoryJobQueue are missing. The 07-quality-architecture.md spec requires these test doubles for black box testing (M1.8), but only InMemoryVideoRepository has been implemented. Without these doubles, integration tests cannot run in isolation from real storage and must use the actual database, making tests slow and non-deterministic.",
      "acceptance_criteria": [
        {
          "text": "InMemoryProjectStorage implements AsyncProjectRepository protocol with deepcopy isolation",
          "done": false
        },
        {
          "text": "InMemoryJobQueue provides synchronous deterministic execution with configurable outcomes",
          "done": false
        },
        {
          "text": "Both doubles include seed helpers for populating test data",
          "done": false
        },
        {
          "text": "Contract tests verify InMemory behavior matches real SQLite implementations",
          "done": false
        }
      ],
      "notes": "Use case: A developer writing integration tests for the project management API needs to verify that creating a project, adding clips, and rendering produces the correct FFmpeg command — without touching the real database or file system. They instantiate InMemoryProjectStorage and InMemoryJobQueue, seed them with test data, wire them into the app, and assert on outcomes deterministically.",
      "use_case": "This feature addresses: Implement InMemory test doubles for Projects and Jobs. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "test-foundation"
    },
    {
      "id": "BL-021",
      "title": "Add dependency injection to create_app() for test wiring",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:56:42.085445",
      "completed_at": "2026-02-09T06:28:49.818774",
      "tags": [
        "v004",
        "testing",
        "dependency-injection"
      ],
      "description": "The `create_app()` factory exists but does not accept injectable dependencies as specified in 07-quality-architecture.md. Tests currently cannot swap in recording or in-memory fakes at the application level. This blocks black box testing (M1.8) because there is no way to wire test doubles into the running FastAPI app without monkey-patching.",
      "acceptance_criteria": [
        {
          "text": "create_app() accepts optional executor, repository, and job queue parameters",
          "done": false
        },
        {
          "text": "Default behavior unchanged — production uses real implementations when None passed",
          "done": false
        },
        {
          "text": "Test mode injects recording/in-memory fakes through the same interface",
          "done": false
        },
        {
          "text": "At least one integration test demonstrates the test wiring end-to-end",
          "done": false
        }
      ],
      "notes": "Use case: A test author needs to verify end-to-end API behavior with recording fakes. They call create_app(executor=RecordingFFmpegExecutor(), repository=InMemoryVideoRepository()) and get a fully wired FastAPI app where every dependency is a test double — no monkey-patching, no module-level globals to swap.",
      "use_case": "This feature addresses: Add dependency injection to create_app() for test wiring. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "test-foundation"
    },
    {
      "id": "BL-022",
      "title": "Build fixture factory with builder pattern for test data",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:56:48.722950",
      "completed_at": "2026-02-09T06:28:50.928000",
      "tags": [
        "v004",
        "testing",
        "fixtures"
      ],
      "description": "No builder-pattern fixture factory exists for creating test data. Tests currently construct project and clip objects inline with repetitive setup code. The 07-quality-architecture.md spec requires `with_clip()`, `with_text_overlay()`, `build()`, and `create_via_api()` methods. Without a fixture factory, tests are verbose, inconsistent, and fragile when data models change.",
      "acceptance_criteria": [
        {
          "text": "Builder creates test projects with configurable clips and effects via chained methods",
          "done": false
        },
        {
          "text": "build() returns domain objects directly for unit tests without HTTP",
          "done": false
        },
        {
          "text": "create_via_api() exercises the full HTTP path for black box tests",
          "done": false
        },
        {
          "text": "Pytest fixtures use the factory, replacing inline test data construction",
          "done": false
        }
      ],
      "notes": "Use case: A developer writes a test for clip reordering. Instead of 15 lines of manual dict construction, they write ProjectBuilder().with_clip(start=0, end=5).with_clip(start=5, end=10).build() and get a valid Project with two clips. When the Clip model adds a new required field next version, only the builder needs updating — not every test.",
      "use_case": "This feature addresses: Build fixture factory with builder pattern for test data. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "test-foundation"
    },
    {
      "id": "BL-023",
      "title": "Implement black box test scenario catalog",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:56:54.536604",
      "completed_at": "2026-02-09T06:28:52.100090",
      "tags": [
        "v004",
        "testing",
        "black-box"
      ],
      "description": "No black box integration tests exist despite the API being stable since v003. The 07-quality-architecture.md spec requires tests that exercise complete workflows through the REST API using real Rust core plus recording fakes. Without these tests, regressions in end-to-end flows (scan → project → clips) go undetected until manual testing.",
      "acceptance_criteria": [
        {
          "text": "Core workflow test covers scan → project → clips flow through REST API",
          "done": false
        },
        {
          "text": "Error handling tests cover validation errors and FFmpeg failure scenarios",
          "done": false
        },
        {
          "text": "All tests use recording test doubles and never mock the Rust core directly",
          "done": false
        },
        {
          "text": "Tests run in CI without FFmpeg installed",
          "done": false
        },
        {
          "text": "pytest markers separate black box tests from unit tests",
          "done": false
        }
      ],
      "notes": "Use case: After refactoring the scan endpoint to be async, a developer runs the black box test suite. Tests exercise the full scan → project → clips workflow through HTTP requests against a real FastAPI app with recording fakes. A regression where scan results no longer populate the video library is caught before it reaches main.",
      "use_case": "This feature addresses: Implement black box test scenario catalog. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "blackbox-contract"
    },
    {
      "id": "BL-024",
      "title": "Contract tests with real FFmpeg for executor fidelity",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:04.009812",
      "completed_at": "2026-02-09T06:28:53.206836",
      "tags": [
        "v004",
        "testing",
        "ffmpeg",
        "contract"
      ],
      "description": "RecordingFFmpegExecutor and FakeFFmpegExecutor exist from v001-v002, but no tests verify they produce behavior identical to RealFFmpegExecutor. This was explicitly deferred from v001 and is required by M1.9 (quality verification). Without contract tests, recording fakes may silently diverge from real FFmpeg behavior, undermining the validity of all integration tests that rely on them.",
      "acceptance_criteria": [
        {
          "text": "Parametrized tests run the same commands against Real, Recording, and Fake executors",
          "done": false
        },
        {
          "text": "At least 5 representative FFmpeg commands tested across executor implementations",
          "done": false
        },
        {
          "text": "Tests marked with @pytest.mark.requires_ffmpeg for CI environments without FFmpeg",
          "done": false
        },
        {
          "text": "Contract violations between fake and real executor fail the test suite",
          "done": false
        }
      ],
      "notes": "Use case: The RecordingFFmpegExecutor is used in all integration tests. A developer changes how FFmpeg handles concat operations in the real executor. Without contract tests, the recording fake still returns old behavior, and integration tests pass even though real FFmpeg would fail. Contract tests catch the divergence by running identical commands against both executors.",
      "use_case": "This feature addresses: Contract tests with real FFmpeg for executor fidelity. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "blackbox-contract"
    },
    {
      "id": "BL-025",
      "title": "Security audit of Rust path validation and input sanitization",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:10.187170",
      "completed_at": "2026-02-09T06:28:54.370009",
      "tags": [
        "v004",
        "security",
        "audit"
      ],
      "description": "M1.9 specifies a security review of Rust sanitization covering path traversal, null bytes, and shell injection vectors. The Rust core handles user-provided file paths and filter text (via `escape_filter_text()`), but no formal audit artifact documents what has been reviewed, what attack vectors are covered, and where gaps remain. Without this audit, security coverage is implicit and unverifiable.",
      "acceptance_criteria": [
        {
          "text": "Review covers path traversal, null byte injection, and shell injection vectors in Rust core",
          "done": false
        },
        {
          "text": "Audit document published in docs/ with findings and coverage assessment",
          "done": false
        },
        {
          "text": "Any identified gaps addressed with new tests or code fixes",
          "done": false
        }
      ],
      "notes": "Use case: A user provides a file path like \"../../etc/passwd\" or a text overlay containing shell metacharacters. The Rust core must reject these inputs before they reach FFmpeg. The security audit documents which attack vectors are tested, which code paths handle them, and whether any gaps exist — giving the team confidence that user input cannot escape the sandbox.",
      "use_case": "This feature addresses: Security audit of Rust path validation and input sanitization. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "security-performance"
    },
    {
      "id": "BL-026",
      "title": "Rust vs Python performance benchmark for core operations",
      "priority": "P3",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:15.444447",
      "completed_at": "2026-02-09T06:28:55.484143",
      "tags": [
        "v004",
        "benchmarking",
        "rust"
      ],
      "description": "M1.9 requires benchmarking Rust core operations against pure-Python equivalents to validate the performance justification for the hybrid architecture. No benchmark infrastructure exists. Without measured speedup ratios, the decision to use Rust for timeline math and filter generation lacks empirical backing.",
      "acceptance_criteria": [
        {
          "text": "Benchmark script compares Rust vs Python for at least 3 representative operations",
          "done": false
        },
        {
          "text": "Results documented with speedup ratios for each operation",
          "done": false
        },
        {
          "text": "Benchmark runnable via uv run python benchmarks/ command",
          "done": false
        }
      ],
      "notes": "Use case: A stakeholder asks whether the Rust/Python hybrid architecture is justified. The benchmark suite runs timeline calculations, filter generation, and clip validation in both pure Python and Rust, producing a comparison table showing that Rust is N× faster for each operation — providing empirical evidence for the architecture decision.",
      "use_case": "This feature addresses: Rust vs Python performance benchmark for core operations. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "security-performance"
    },
    {
      "id": "BL-027",
      "title": "Async job queue for scan operations",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:21.142515",
      "completed_at": "2026-02-09T06:28:56.559249",
      "tags": [
        "v004",
        "async",
        "scan"
      ],
      "description": "The scan endpoint blocks the HTTP request until the entire directory scan completes. This was identified as tech debt in the v003 retrospective. For large media directories, scan can take significant time, leaving the client with no progress feedback. The black box test scenario catalog (M1.8) also requires async scan behavior to test job progress workflows.",
      "acceptance_criteria": [
        {
          "text": "Scan endpoint returns job ID immediately instead of blocking",
          "done": false
        },
        {
          "text": "Job status queryable via GET endpoint with progress information",
          "done": false
        },
        {
          "text": "InMemoryJobQueue supports synchronous test execution for deterministic tests",
          "done": false
        },
        {
          "text": "Existing scan tests updated to use the async pattern",
          "done": false
        }
      ],
      "notes": "Use case: A user starts a scan of a large media directory (10,000+ files). Instead of waiting 30 seconds for the HTTP response, they get a job ID back immediately and can poll for progress. The GUI shows a progress bar updating in real-time. If they navigate away and come back, the job status endpoint tells them the scan is 73% complete.",
      "use_case": "This feature addresses: Async job queue for scan operations. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v004",
      "implemented_in_theme": "async-scan"
    },
    {
      "id": "BL-028",
      "title": "EXP: Frontend framework selection and Vite project setup",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:38.184470",
      "completed_at": "2026-02-09T18:43:02.397488",
      "tags": [
        "v005",
        "gui",
        "investigation"
      ],
      "description": "No frontend project exists — no `gui/` directory, package.json, or framework choice has been finalized. The 08-gui-architecture.md suggests React 18+ or Svelte 4+ with Vite and Tailwind. BL-003 covers investigating FastAPI static file serving but not the framework decision or project scaffolding. All v005 GUI milestones (M1.10–M1.12) are blocked until a frontend project is in place.",
      "acceptance_criteria": [
        {
          "text": "Framework selected (React vs Svelte) with documented rationale",
          "done": false
        },
        {
          "text": "gui/ project scaffolded with Vite, Tailwind CSS, and TypeScript",
          "done": false
        },
        {
          "text": "npm run build produces gui/dist/ with a working bundle",
          "done": false
        },
        {
          "text": "FastAPI serves the built frontend at /gui/* routes",
          "done": false
        },
        {
          "text": "Dev proxy configured for Vite HMR during development",
          "done": false
        }
      ],
      "notes": "Use case: A user opens the application URL and expects to see a functioning web interface. Currently there is no frontend at all — no gui/ directory, no package.json, no framework. This item bootstraps the entire frontend project so that subsequent GUI features (shell, dashboard, library browser) have a foundation to build on.",
      "use_case": "This feature addresses: EXP: Frontend framework selection and Vite project setup. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "frontend-foundation"
    },
    {
      "id": "BL-029",
      "title": "Implement WebSocket endpoint for real-time events",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:43.982521",
      "completed_at": "2026-02-09T18:43:03.473592",
      "tags": [
        "v005",
        "websocket",
        "api"
      ],
      "description": "M1.10 requires a `/ws` WebSocket endpoint for real-time event broadcasting, but no WebSocket support exists in the current FastAPI app. The application shell needs live health status updates and the dashboard needs an activity feed. Without WebSocket support, the GUI must resort to polling, creating unnecessary load and delayed feedback.",
      "acceptance_criteria": [
        {
          "text": "/ws endpoint accepts WebSocket connections with proper handshake",
          "done": false
        },
        {
          "text": "Health status changes broadcast to all connected clients",
          "done": false
        },
        {
          "text": "Activity events (scan started/completed, project created) broadcast in real time",
          "done": false
        },
        {
          "text": "Connection lifecycle tested: connect, disconnect, reconnect scenarios",
          "done": false
        },
        {
          "text": "WebSocket messages include correlation IDs from existing middleware",
          "done": false
        }
      ],
      "notes": "Use case: A user triggers a directory scan from the library browser and sees a spinning indicator while the scan runs. When the scan completes, the video grid updates automatically without a page refresh. This real-time feedback requires WebSocket push from the server — without it, the user must manually refresh to see new videos.",
      "use_case": "This feature addresses: Implement WebSocket endpoint for real-time events. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "frontend-foundation"
    },
    {
      "id": "BL-030",
      "title": "Build application shell and navigation components",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:50.109098",
      "completed_at": "2026-02-09T18:43:04.589424",
      "tags": [
        "v005",
        "gui",
        "shell"
      ],
      "description": "M1.10 specifies an application shell with navigation tabs, status bar, and health indicator, but no frontend components exist. The shell is the frame that hosts all other GUI panels (library browser, project manager, effect workshop). Without it, individual components have no layout structure or navigation context.",
      "acceptance_criteria": [
        {
          "text": "Navigation between Dashboard, Library, and Projects tabs works with URL routing",
          "done": false
        },
        {
          "text": "Health indicator polls /health/ready and displays green/yellow/red status",
          "done": false
        },
        {
          "text": "Status bar displays WebSocket connection state",
          "done": false
        },
        {
          "text": "Progressive tabs — only shows features whose backends are available",
          "done": false
        },
        {
          "text": "Component unit tests pass in Vitest",
          "done": false
        }
      ],
      "notes": "Use case: A user navigates between the Dashboard, Library, and Projects tabs using the top navigation bar. The status bar at the bottom shows a green health indicator confirming the backend is reachable. When the server goes down, the indicator turns red and unavailable tabs are hidden, preventing the user from interacting with broken features.",
      "use_case": "This feature addresses: Build application shell and navigation components. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "gui-components"
    },
    {
      "id": "BL-031",
      "title": "Build dashboard panel with health cards and activity log",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:57:55.468176",
      "completed_at": "2026-02-09T18:43:05.793196",
      "tags": [
        "v005",
        "gui",
        "dashboard"
      ],
      "description": "M1.10 specifies a dashboard with system health cards, recent activity log, and metrics overview. No dashboard component exists. The dashboard is the landing page and primary system health visibility tool. Without it, users have no centralized view of component status (Python, Rust core, FFmpeg) or recent system activity.",
      "acceptance_criteria": [
        {
          "text": "Health cards display individual component status (Python, Rust core, FFmpeg)",
          "done": false
        },
        {
          "text": "Activity log receives and displays WebSocket events in real time",
          "done": false
        },
        {
          "text": "Metrics cards show API request count and Rust operation timing from /metrics",
          "done": false
        },
        {
          "text": "Dashboard auto-refreshes on a configurable interval",
          "done": false
        }
      ],
      "notes": "Use case: A user opens the application and lands on the dashboard. They see health cards showing Python (green), Rust core (green), and FFmpeg (yellow — not installed). The activity log shows the last scan completed 5 minutes ago with 12 new videos found. This gives the user immediate system awareness without digging into logs or API responses.",
      "use_case": "This feature addresses: Build dashboard panel with health cards and activity log. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "gui-components"
    },
    {
      "id": "BL-032",
      "title": "Implement thumbnail generation pipeline for video library",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:58:04.504476",
      "completed_at": "2026-02-09T18:43:07.083333",
      "tags": [
        "v005",
        "thumbnails",
        "ffmpeg"
      ],
      "description": "The library browser spec (M1.11) assumes thumbnail display for videos, but no thumbnail generation pipeline exists. Videos are scanned and stored with metadata, but no representative frame is extracted. Without thumbnails, the library browser would display a text-only list, degrading the visual browsing experience that is core to a video editing tool.",
      "acceptance_criteria": [
        {
          "text": "Thumbnail generated during video scan or on first access",
          "done": false
        },
        {
          "text": "GET /api/videos/{id}/thumbnail returns the thumbnail image",
          "done": false
        },
        {
          "text": "Configurable thumbnail size with default 320x180",
          "done": false
        },
        {
          "text": "Graceful fallback returns a placeholder for videos where extraction fails",
          "done": false
        },
        {
          "text": "RecordingFFmpegExecutor captures thumbnail generation commands for testing",
          "done": false
        }
      ],
      "notes": "Use case: A user browses the video library and sees thumbnail previews for each video instead of text-only filenames. When a new video is scanned, a representative frame is extracted and stored. For corrupt or unsupported files, a placeholder image is shown so the grid layout remains consistent.",
      "use_case": "This feature addresses: Implement thumbnail generation pipeline for video library. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "backend-services"
    },
    {
      "id": "BL-033",
      "title": "Build library browser with video grid, search, and scan UI",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:58:10.196219",
      "completed_at": "2026-02-09T18:43:08.087942",
      "tags": [
        "v005",
        "gui",
        "library"
      ],
      "description": "M1.11 specifies a library browser with video grid, search, sort/filter, and scan controls. No frontend components for video display exist. The library browser is the primary entry point for working with media — users need to find, browse, and select videos before creating projects. The backend API endpoints (search, list, scan) exist from v003 but have no GUI consumer.",
      "acceptance_criteria": [
        {
          "text": "Video grid displays thumbnails, filename, and duration for each video",
          "done": false
        },
        {
          "text": "Search bar calls /api/videos/search with debounced input",
          "done": false
        },
        {
          "text": "Sort by date, name, or duration updates the grid",
          "done": false
        },
        {
          "text": "Scan modal triggers directory scan and shows progress feedback",
          "done": false
        },
        {
          "text": "Virtual scrolling or pagination handles libraries with 100+ videos",
          "done": false
        }
      ],
      "notes": "Use case: A user wants to find a specific clip in a library of 200+ videos. They type a partial filename in the search bar and see results update as they type. They sort by date to find recently added clips, then click the Scan button to add videos from a new directory. The scan modal shows progress and the grid updates when new files are found.",
      "use_case": "This feature addresses: Build library browser with video grid, search, and scan UI. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "gui-components"
    },
    {
      "id": "BL-034",
      "title": "Fix pagination total count for list endpoints",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:58:15.599657",
      "completed_at": "2026-02-09T18:43:09.091777",
      "tags": [
        "v005",
        "api",
        "pagination"
      ],
      "description": "Paginated list endpoints return page-based results but lack a true total count. This was identified as tech debt in the v003 retrospective. The library browser needs the total count for virtual scrolling (to size the scroll container) and for displaying \"X of Y results\" feedback. Without it, the frontend cannot accurately represent the full dataset size.",
      "acceptance_criteria": [
        {
          "text": "List endpoints return a total field with the full count of matching items",
          "done": false
        },
        {
          "text": "Search endpoint returns total matching results separate from page size",
          "done": false
        },
        {
          "text": "Existing pagination tests updated to verify total count accuracy",
          "done": false
        }
      ],
      "notes": "Use case: The library browser displays \"Showing 20 of ?\" because the API returns paginated results without a total count. With the fix, it shows \"Showing 20 of 247 videos\" and the scrollbar accurately represents the full dataset size, enabling smooth virtual scrolling through large libraries.",
      "use_case": "This feature addresses: Fix pagination total count for list endpoints. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "backend-services"
    },
    {
      "id": "BL-035",
      "title": "Build project manager with list, creation, and details views",
      "priority": "P1",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:58:20.785944",
      "completed_at": "2026-02-09T18:43:10.193544",
      "tags": [
        "v005",
        "gui",
        "projects"
      ],
      "description": "M1.12 specifies a project manager with project list, creation modal, and details view showing Rust-calculated timeline positions. No frontend components for project management exist. The project API endpoints exist from v003, but users cannot create, browse, or inspect projects through the GUI. This is the last GUI milestone in Phase 1.",
      "acceptance_criteria": [
        {
          "text": "Project list displays name, creation date, and clip count",
          "done": false
        },
        {
          "text": "New Project modal validates output settings (resolution, fps, format)",
          "done": false
        },
        {
          "text": "Project details view displays clip list with Rust-calculated timeline positions",
          "done": false
        },
        {
          "text": "Delete action requires confirmation dialog before execution",
          "done": false
        },
        {
          "text": "Component unit tests pass in Vitest",
          "done": false
        }
      ],
      "notes": "Use case: A user clicks \"New Project\", enters output settings (1080p, 30fps, MP4), and creates a project. They navigate to the project list, see it alongside other projects, and click through to the details view where clips are listed with Rust-calculated timeline positions showing start/end times. They can delete old projects with a confirmation dialog to prevent accidents.",
      "use_case": "This feature addresses: Build project manager with list, creation, and details views. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "gui-components"
    },
    {
      "id": "BL-036",
      "title": "Set up Playwright E2E test infrastructure for GUI",
      "priority": "P2",
      "status": "completed",
      "size": "m",
      "added": "2026-02-08T17:58:25.894825",
      "completed_at": "2026-02-09T18:43:11.355663",
      "tags": [
        "v005",
        "testing",
        "e2e"
      ],
      "description": "The 08-gui-architecture.md quality requirements specify Playwright for E2E testing, but no E2E test infrastructure exists. Unit tests (Vitest) cover individual components, but there are no tests verifying that the full stack (FastAPI + built frontend) works end-to-end. Without E2E tests, regressions in the integration between frontend and backend go undetected.",
      "acceptance_criteria": [
        {
          "text": "Playwright configured with CI integration in GitHub Actions",
          "done": false
        },
        {
          "text": "At least 3 E2E tests covering navigation, scan trigger, and project creation",
          "done": false
        },
        {
          "text": "Tests run against FastAPI serving the built frontend bundle",
          "done": false
        },
        {
          "text": "Accessibility checks (WCAG AA) included in test assertions",
          "done": false
        }
      ],
      "notes": "Use case: A developer pushes a change to the library browser component. CI runs Playwright tests that verify the full stack: FastAPI serves the built frontend, the browser navigates between tabs, a scan can be triggered, and a new project can be created. If the integration between frontend and backend breaks, the E2E tests catch it before merge.",
      "use_case": "This feature addresses: Set up Playwright E2E test infrastructure for GUI. It improves the system by resolving the described requirement.",
      "implemented_in_version": "v005",
      "implemented_in_theme": "e2e-testing"
    },
    {
      "id": "BL-037",
      "title": "Implement FFmpeg filter expression engine in Rust",
      "priority": "P1",
      "status": "open",
      "size": "l",
      "added": "2026-02-08T17:58:45.828090",
      "completed_at": null,
      "tags": [
        "v006",
        "rust",
        "filters",
        "expressions"
      ],
      "description": "The current filter system (v001) handles simple key=value parameters only. FFmpeg filter expressions like `enable='between(t,3,5)'`, alpha expressions, and time-based arithmetic have no Rust representation. M2.1 requires a type-safe expression builder that prevents syntactically invalid expressions. Without this, text overlay animations (M2.2), speed control (M2.3), and all v007 effects cannot be built safely.",
      "acceptance_criteria": [
        {
          "text": "Expression types cover enable, alpha, time, and arithmetic expressions",
          "done": false
        },
        {
          "text": "Builder API prevents construction of syntactically invalid expressions at compile time",
          "done": false
        },
        {
          "text": "Expressions serialize to valid FFmpeg filter syntax strings",
          "done": false
        },
        {
          "text": "Property-based tests (proptest) generate random valid expressions and verify serialization",
          "done": false
        },
        {
          "text": "PyO3 bindings expose expression builder to Python with type stubs",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement FFmpeg filter expression engine in Rust. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-038",
      "title": "Implement filter graph validation for pad matching",
      "priority": "P1",
      "status": "open",
      "size": "l",
      "added": "2026-02-08T17:58:50.346126",
      "completed_at": null,
      "tags": [
        "v006",
        "rust",
        "filters",
        "validation"
      ],
      "description": "The current FilterGraph (v001) builds FFmpeg filter strings but performs no validation of input/output pad matching. Invalid graphs (unconnected pads, cycles, mismatched labels) are only caught when FFmpeg rejects the command at runtime. M2.1 requires compile-time-safe graph construction. Without validation, complex filter graphs for effects composition will produce cryptic FFmpeg errors instead of actionable messages.",
      "acceptance_criteria": [
        {
          "text": "Pad labels validated for correct matching (output label feeds matching input label)",
          "done": false
        },
        {
          "text": "Unconnected pads detected and reported with the specific pad name",
          "done": false
        },
        {
          "text": "Graph cycles detected and rejected before serialization",
          "done": false
        },
        {
          "text": "Validation error messages include actionable guidance on how to fix the graph",
          "done": false
        },
        {
          "text": "Existing FilterGraph tests updated to cover validation",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement filter graph validation for pad matching. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-039",
      "title": "Build filter composition system for chaining, branching, and merging",
      "priority": "P1",
      "status": "open",
      "size": "l",
      "added": "2026-02-08T17:58:55.785960",
      "completed_at": null,
      "tags": [
        "v006",
        "rust",
        "filters",
        "composition"
      ],
      "description": "No support exists for composing filter chains programmatically. The current system builds individual filters but cannot chain them sequentially, branch one stream into multiple, or merge multiple streams (e.g., overlay, amix). M2.1 requires a composition API for building complex filter graphs. Without it, every effect combination must manually construct raw filter strings, which is error-prone and unvalidatable.",
      "acceptance_criteria": [
        {
          "text": "Chain composition applies filters sequentially to a single stream",
          "done": false
        },
        {
          "text": "Branch splits one stream into multiple output streams",
          "done": false
        },
        {
          "text": "Merge combines multiple streams using overlay, amix, or concat",
          "done": false
        },
        {
          "text": "Composed graphs pass FilterGraph validation automatically",
          "done": false
        },
        {
          "text": "PyO3 bindings expose composition API to Python with type stubs",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Build filter composition system for chaining, branching, and merging. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-040",
      "title": "Implement drawtext filter builder for text overlays",
      "priority": "P1",
      "status": "open",
      "size": "l",
      "added": "2026-02-08T17:59:02.289043",
      "completed_at": null,
      "tags": [
        "v006",
        "rust",
        "text-overlay"
      ],
      "description": "The `escape_filter_text()` function exists in the Rust sanitize module, but no structured drawtext builder handles position, font, color, shadow, box background, or alpha animation parameters. M2.2 requires a type-safe text overlay system. Without a builder, constructing drawtext filters requires manually assembling complex parameter strings with correct escaping — a frequent source of FFmpeg errors.",
      "acceptance_criteria": [
        {
          "text": "Position options support absolute coordinates, centered, and margin-based placement",
          "done": false
        },
        {
          "text": "Styling covers font size, color, shadow offset/color, and box background",
          "done": false
        },
        {
          "text": "Alpha animation supports fade in/out with configurable duration using expression engine",
          "done": false
        },
        {
          "text": "Generated drawtext filters validated as syntactically correct FFmpeg syntax",
          "done": false
        },
        {
          "text": "Contract tests verify generated commands pass ffmpeg -filter_complex validation",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement drawtext filter builder for text overlays. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-041",
      "title": "Implement speed control filter builders (setpts/atempo)",
      "priority": "P1",
      "status": "open",
      "size": "m",
      "added": "2026-02-08T17:59:12.246297",
      "completed_at": null,
      "tags": [
        "v006",
        "rust",
        "speed-control"
      ],
      "description": "No Rust types exist for video speed (setpts) or audio speed (atempo) control. M2.3 requires speed adjustment from 0.25x to 4.0x. The atempo filter maxes at 2.0x and requires automatic chaining for higher speeds — a non-obvious FFmpeg detail that should be encapsulated in the builder. Without these builders, speed control must be hand-coded with raw filter strings for each speed value.",
      "acceptance_criteria": [
        {
          "text": "Video speed adjustable via setpts with factor range 0.25x–4.0x",
          "done": false
        },
        {
          "text": "Audio speed via atempo with automatic chaining for factors above 2.0x",
          "done": false
        },
        {
          "text": "Option to drop audio entirely instead of speed-adjusting it",
          "done": false
        },
        {
          "text": "Validation rejects out-of-range values with helpful error messages",
          "done": false
        },
        {
          "text": "Unit tests cover edge cases: 1x (no-op), boundary values, extreme speeds",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement speed control filter builders (setpts/atempo). It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-042",
      "title": "Create effect discovery API endpoint",
      "priority": "P2",
      "status": "open",
      "size": "l",
      "added": "2026-02-08T17:59:18.403862",
      "completed_at": null,
      "tags": [
        "v006",
        "api",
        "effects",
        "discovery"
      ],
      "description": "M2.2 and 05-api-specification.md specify an `/effects` discovery endpoint, but no such endpoint exists. The frontend needs a way to discover available effects with their parameter schemas and AI hints. Without a discovery endpoint, the GUI must hard-code knowledge of available effects, breaking the extensibility model and preventing the v007 Effect Workshop from dynamically generating parameter forms.",
      "acceptance_criteria": [
        {
          "text": "GET /effects returns a list of all available effects",
          "done": false
        },
        {
          "text": "Each effect includes name, description, and parameter JSON schema",
          "done": false
        },
        {
          "text": "AI hints included for each parameter to guide user input",
          "done": false
        },
        {
          "text": "Text overlay and speed control registered as discoverable effects",
          "done": false
        },
        {
          "text": "Response includes Rust-generated filter preview for default parameters",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Create effect discovery API endpoint. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-043",
      "title": "Create API endpoint to apply text overlay effect to clips",
      "priority": "P2",
      "status": "open",
      "size": "l",
      "added": "2026-02-08T17:59:24.988435",
      "completed_at": null,
      "tags": [
        "v006",
        "api",
        "text-overlay"
      ],
      "description": "No API endpoint exists to apply effects to clips. The Rust drawtext builder will generate filter strings, but there is no REST endpoint to receive effect parameters, apply them to a specific clip, and store the configuration in the project model. M2.2 requires this bridge between the Rust effects engine and the clip/project data model. The clip model currently has no field for storing applied effects.",
      "acceptance_criteria": [
        {
          "text": "POST endpoint applies text overlay parameters to a specified clip",
          "done": false
        },
        {
          "text": "Effect configuration stored persistently in the clip/project model",
          "done": false
        },
        {
          "text": "Response includes the generated FFmpeg filter string for transparency",
          "done": false
        },
        {
          "text": "Validation errors from Rust surface as structured API error responses",
          "done": false
        },
        {
          "text": "Black box test covers the apply → verify filter string flow",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Create API endpoint to apply text overlay effect to clips. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-044",
      "title": "Implement audio mixing filter builders (amix/volume/fade)",
      "priority": "P1",
      "status": "open",
      "size": "l",
      "added": "2026-02-08T17:59:41.434479",
      "completed_at": null,
      "tags": [
        "v007",
        "rust",
        "audio",
        "mixing"
      ],
      "description": "No Rust types exist for audio mixing, volume control, or audio fade effects. M2.4 requires amix for combining audio tracks, per-track volume control, fade in/out, and audio ducking patterns. The existing filter system handles video filters only. Without audio builders, mixing multiple audio sources (music + speech) requires manual FFmpeg filter string construction with no validation or ducking automation.",
      "acceptance_criteria": [
        {
          "text": "amix filter builder supports configurable number of input tracks",
          "done": false
        },
        {
          "text": "Per-track volume control validates range 0.0–10.0 using existing validate_volume",
          "done": false
        },
        {
          "text": "Audio fade in/out supports configurable duration via expression engine",
          "done": false
        },
        {
          "text": "Audio ducking pattern lowers music volume during speech segments",
          "done": false
        },
        {
          "text": "Edge case tests cover silence, clipping prevention, and format mismatches",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement audio mixing filter builders (amix/volume/fade). It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-045",
      "title": "Implement transition filter builders (fade/xfade)",
      "priority": "P1",
      "status": "open",
      "size": "m",
      "added": "2026-02-08T17:59:46.825964",
      "completed_at": null,
      "tags": [
        "v007",
        "rust",
        "transitions"
      ],
      "description": "No Rust types exist for video transitions. M2.5 requires fade in, fade out, crossfade between clips, and xfade with selectable transition effects (wipeleft, slideright, etc.). Transitions are fundamental to video editing but currently have no type-safe builder. Without these, transition effects must be manually assembled as raw FFmpeg filter strings with no parameter validation.",
      "acceptance_criteria": [
        {
          "text": "Fade in/out with configurable duration and color",
          "done": false
        },
        {
          "text": "Crossfade between two clips with overlap duration parameter",
          "done": false
        },
        {
          "text": "xfade supports selectable effect types (fade, wipeleft, slideright, etc.)",
          "done": false
        },
        {
          "text": "Parameter validation rejects invalid duration or effect type with helpful messages",
          "done": false
        },
        {
          "text": "PyO3 bindings expose transition builders to Python with type stubs",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement transition filter builders (fade/xfade). It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-046",
      "title": "Create transition API endpoint for clip-to-clip transitions",
      "priority": "P1",
      "status": "open",
      "size": "m",
      "added": "2026-02-08T17:59:51.298982",
      "completed_at": null,
      "tags": [
        "v007",
        "api",
        "transitions"
      ],
      "description": "M2.5 specifies an `/effects/transition` endpoint for applying transitions between adjacent clips, but no such endpoint exists. The Rust transition builders will generate filter strings, but there is no REST endpoint to receive transition parameters, validate clip adjacency, and store the transition in the project timeline. Without this, transitions cannot be applied through the API.",
      "acceptance_criteria": [
        {
          "text": "POST endpoint applies a transition between two specified clips",
          "done": false
        },
        {
          "text": "Validates that the two clips are adjacent in the project timeline",
          "done": false
        },
        {
          "text": "Response includes the generated FFmpeg filter string",
          "done": false
        },
        {
          "text": "Transition configuration stored persistently in the project model",
          "done": false
        },
        {
          "text": "Black box test covers apply transition and verify filter output flow",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Create transition API endpoint for clip-to-clip transitions. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-047",
      "title": "Build effect registry with JSON schema validation and builder protocol",
      "priority": "P1",
      "status": "open",
      "size": "l",
      "added": "2026-02-08T17:59:58.051286",
      "completed_at": null,
      "tags": [
        "v007",
        "registry",
        "effects",
        "schema"
      ],
      "description": "M2.6 specifies a central effect registry where each effect is registered with its JSON schema, Rust validation functions, and builder protocol. The v006 discovery endpoint provides basic listing, but the full registry pattern — schema validation, effect builder injection, and metrics tracking — is missing. Without a registry, each effect is independently wired, making the Effect Workshop GUI unable to dynamically generate forms or validate parameters.",
      "acceptance_criteria": [
        {
          "text": "Registry stores effect metadata, parameter JSON schemas, and builder references",
          "done": false
        },
        {
          "text": "JSON schema validation enforces parameter constraints for all registered effects",
          "done": false
        },
        {
          "text": "Effect builder protocol supports dependency injection for effect construction",
          "done": false
        },
        {
          "text": "All existing effects (text overlay, speed, audio, transitions) registered",
          "done": false
        },
        {
          "text": "effect_applications_total Prometheus counter increments by effect type on application",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Build effect registry with JSON schema validation and builder protocol. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-048",
      "title": "Build effect catalog UI component",
      "priority": "P1",
      "status": "open",
      "size": "m",
      "added": "2026-02-08T18:00:07.485872",
      "completed_at": null,
      "tags": [
        "v007",
        "gui",
        "effects",
        "catalog"
      ],
      "description": "M2.8 specifies an effect catalog component for browsing and selecting available effects, but no such frontend component exists. The `/effects` discovery endpoint (v006) provides the data, but there is no UI to consume it. Users need a visual catalog to discover what effects are available before they can configure and apply them. This is the entry point for the entire Effect Workshop workflow.",
      "acceptance_criteria": [
        {
          "text": "Grid/list view displays available effects fetched from /effects endpoint",
          "done": false
        },
        {
          "text": "Effect cards show name, description, and category",
          "done": false
        },
        {
          "text": "AI hints displayed as contextual tooltips on each effect",
          "done": false
        },
        {
          "text": "Search and filter by category narrows the displayed effects",
          "done": false
        },
        {
          "text": "Clicking an effect opens its parameter configuration form",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Build effect catalog UI component. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-049",
      "title": "Build dynamic parameter form generator from JSON schema",
      "priority": "P1",
      "status": "open",
      "size": "l",
      "added": "2026-02-08T18:00:14.349552",
      "completed_at": null,
      "tags": [
        "v007",
        "gui",
        "effects",
        "forms"
      ],
      "description": "M2.8 specifies auto-generating parameter forms from JSON schema, but no dynamic form rendering component exists. Each effect has a unique parameter schema (from the effect registry), and building static forms per effect doesn't scale. Without a schema-driven form generator, every new effect requires custom frontend code for its parameter UI, and the live filter preview feature cannot work generically.",
      "acceptance_criteria": [
        {
          "text": "Forms generated dynamically from effect JSON schema definitions",
          "done": false
        },
        {
          "text": "Supports parameter types: number (with range slider), string, enum (dropdown), boolean, color picker",
          "done": false
        },
        {
          "text": "Inline validation displays error messages from Rust validation",
          "done": false
        },
        {
          "text": "Live filter string preview updates as parameter values change",
          "done": false
        },
        {
          "text": "Default values pre-populated from the JSON schema",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Build dynamic parameter form generator from JSON schema. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-050",
      "title": "Implement live FFmpeg filter preview in effect parameter UI",
      "priority": "P1",
      "status": "open",
      "size": "m",
      "added": "2026-02-08T18:00:19.762113",
      "completed_at": null,
      "tags": [
        "v007",
        "gui",
        "preview",
        "transparency"
      ],
      "description": "M2.8 specifies showing the Rust-generated FFmpeg filter string in real time as users adjust effect parameters. This is the core transparency feature — users see exactly what commands Rust generates. No such preview component exists. Without live preview, the tool's key differentiator (transparency into FFmpeg command generation) is invisible during effect configuration.",
      "acceptance_criteria": [
        {
          "text": "Filter string panel displays the current FFmpeg filter and updates on parameter change",
          "done": false
        },
        {
          "text": "API calls to get filter preview are debounced to avoid excessive requests",
          "done": false
        },
        {
          "text": "FFmpeg filter syntax displayed with syntax highlighting",
          "done": false
        },
        {
          "text": "Copy-to-clipboard button copies the filter string for external use",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Implement live FFmpeg filter preview in effect parameter UI. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-051",
      "title": "Build effect builder workflow with clip selector and effect stack",
      "priority": "P1",
      "status": "open",
      "size": "l",
      "added": "2026-02-08T18:00:26.538591",
      "completed_at": null,
      "tags": [
        "v007",
        "gui",
        "effects",
        "builder"
      ],
      "description": "M2.9 specifies a complete effect builder workflow: select effect, configure parameters, choose target clip, view the effect stack per clip, and edit/remove applied effects. No such workflow exists. Individual components (catalog, form, preview) need to be composed into a coherent workflow. Without this, users cannot complete the full loop of discovering, configuring, applying, and managing effects on clips.",
      "acceptance_criteria": [
        {
          "text": "Apply to Clip workflow presents a clip selector from the current project",
          "done": false
        },
        {
          "text": "Effect stack visualization shows all effects applied to a selected clip in order",
          "done": false
        },
        {
          "text": "Preview thumbnail displays a static frame with the effect applied",
          "done": false
        },
        {
          "text": "Edit action re-opens parameter form with existing values for an applied effect",
          "done": false
        },
        {
          "text": "Remove action deletes an effect from a clip's effect stack with confirmation",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: Build effect builder workflow with clip selector and effect stack. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    },
    {
      "id": "BL-052",
      "title": "E2E tests for effect workshop workflow",
      "priority": "P2",
      "status": "open",
      "size": "m",
      "added": "2026-02-08T18:00:32.690882",
      "completed_at": null,
      "tags": [
        "v007",
        "testing",
        "e2e",
        "effects"
      ],
      "description": "The effect workshop comprises multiple GUI components (catalog, form generator, preview, builder workflow) that must work together end-to-end. No E2E tests cover this workflow. The v005 Playwright infrastructure provides the foundation, but effect-specific test scenarios are needed. Without E2E coverage, regressions in the multi-step effect application workflow go undetected.",
      "acceptance_criteria": [
        {
          "text": "E2E test browses effect catalog and selects an effect",
          "done": false
        },
        {
          "text": "E2E test configures parameters and verifies filter preview updates in real time",
          "done": false
        },
        {
          "text": "E2E test applies effect to a clip and verifies effect stack display",
          "done": false
        },
        {
          "text": "E2E test edits and removes an applied effect successfully",
          "done": false
        },
        {
          "text": "Accessibility checks (WCAG AA) pass for all form components",
          "done": false
        }
      ],
      "notes": null,
      "use_case": "This feature addresses: E2E tests for effect workshop workflow. It improves the system by resolving the described requirement.",
      "implemented_in_version": null,
      "implemented_in_theme": null
    }
  ],
  "completed_count": 32,
  "cancelled_count": 0
}